Asmc Macro Assembler (x64) Version 2.33.27
D:\Asmc\source\asmc\x64\ltype.asm
00000000                    *   _TEXT segment PARA FLAT PUBLIC 'CODE'
                            *   _TEXT ends
00000000                    *   _DATA segment PARA FLAT PUBLIC 'DATA'
                            *   _DATA ends
                            *   assume cs:flat,ds:flat,ss:flat,es:flat,fs:ERROR,gs:NOTHING
                                ; _LTYPE.ASM--
                                ;
                                ; Copyright (c) The Asmc Contributors. All rights reserved.
                                ; Consult your license regarding permissions and restrictions.
                                ;

                                include asmc.inc
                              C ; ASMC.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ifndef __ASMC_INC
 = 0                          C define __ASMC_INC
                              C 
                              C include version.inc
                              C ifndef __INC_VERSION
 = 0                          C define __INC_VERSION
                              C 
 = E9                         C define ASMC_VERSION         233
                              C 
 = 2                          C define ASMC_MAJOR_VER       2
 = 21                         C define ASMC_MINOR_VER       33
 = 1B                         C define ASMC_SUBMINOR_VER    27
                              C 
 = "2.33.27"                  C define ASMC_VERSSTR         <"2.33.27">
                              C 
                              C endif
                              C include stdio.inc
                              C ifndef __STDIO_INC
 = 0                          C define __STDIO_INC
                              C endif
                              C include stdlib.inc
                              C ifndef __STDLIB_INC
 = 0                          C define __STDLIB_INC
                              C include libc.inc
                              C ifndef __LIBC_INC
                              C endif
                              C 
                              C ifndef _ERRNO_T_DEFINED
 = 0                          C define _ERRNO_T_DEFINED
                              C errno_t typedef sdword
                              C endif
                              C 
                              C ifndef _INTPTR_T_DEFINED
 = 0                          C define _INTPTR_T_DEFINED
                              C ifdef _WIN64
                              C intptr_t typedef sqword
                              C endif
                              C endif
                              C 
                              C ifndef _UINTPTR_T_DEFINED
 = 0                          C define _UINTPTR_T_DEFINED
                              C ifdef _WIN64
                              C uintptr_t typedef qword
                              C endif
                              C endif
                              C 
                              C ifndef _THREADLOCALEINFO
 = 0                          C define _THREADLOCALEINFO
                              C ifndef LPSHORT
                              C LPINT	typedef ptr sdword
                              C LPSHORT typedef ptr sword
                              C endif
                              C .template locrefcount
00000000                    * C locrefcount struct
00000000                      C     locale		LPSTR ?
00000008                      C     wlocale		LPWSTR ?
00000010                      C     refcount		LPINT ?
00000018                      C     wrefcount		LPINT ?
                              C    .ends
00000020                    * C locrefcount ends
                              C .template threadlocinfo
00000000                    * C threadlocinfo struct
00000000                      C     refcount		SINT ?
00000004                      C     lc_codepage		UINT ?
00000008                      C     lc_collate_cp	UINT ?
0000000C                      C     lc_time_cp		UINT ?
00000010                      C     lc_category		locrefcount 6 dup(<>)
000000D0                      C     lc_clike		SINT ?
000000D4                      C     mb_cur_max		SINT ?
000000D8                      C     lconv_intl_refcount LPINT ?
000000E0                      C     lconv_num_refcount	LPINT ?
000000E8                      C     lconv_mon_refcount	LPINT ?
000000F0                      C     lconvp		PVOID ?
000000F8                      C     ctype1_refcount	LPINT ?
00000100                      C     ctype1		LPSHORT ?
00000108                      C     pctype		LPSHORT ?
00000110                      C     pclmap		LPSTR ?
00000118                      C     pcumap		LPSTR ?
00000120                      C     lc_time_curr	ptr __lc_time_data ?
00000128                      C     locale_name		LPWSTR 6 dup(?)
                              C    .ends
00000158                    * C threadlocinfo ends
                              C     pthreadlocinfo	typedef ptr threadlocinfo
                              C endif
                              C 
                              C ifndef _locale_t
                              C .template _locale_tstruct
00000000                    * C _locale_tstruct struct
00000000                      C     locinfo		ptr threadlocinfo ?
00000008                      C     mbcinfo		ptr threadmbcinfo ?
                              C    .ends
00000010                    * C _locale_tstruct ends
                              C    _locale_t		typedef ptr _locale_tstruct
                              C endif
                              C 
                              C ifndef __STDC_WANT_SECURE_LIB__
 = 1                          C define __STDC_WANT_SECURE_LIB__ 1
                              C endif
                              C 
                              C include limits.inc
                              C 
                              C .pragma comment(lib, libc, msvcrt)
                            * C ifdef _MSVCRT
                            * C else
                            * C includelib libc.lib
                            * C endif
                              C 
                              C ifndef _ONEXIT_T_DEFINED
 = 0                          C define _ONEXIT_T_DEFINED
                              C 
                              C ifndef _M_CEE_PURE
                             1C     ?_onexit_t typedef proto fastcall 
                              C _onexit_t typedef ptr ?_onexit_t
                              C endif
                              C 
                              C ifdef _M_CEE_MIXED
                              C endif
                              C 
                              C if not __STDC__
                              C onexit_t typedef _onexit_t
                              C endif
                              C 
                              C endif
                              C 
                              C ifndef _DIV_T_DEFINED
 = 0                          C define _DIV_T_DEFINED
00000000                      C _div_t		struct
00000000                      C quot		int_t ?
00000004                      C rem		int_t ?
00000008                      C _div_t		ends
00000000                      C _ldiv_t		struct
00000000                      C quot		long_t ?
00000004                      C rem		long_t ?
00000008                      C _ldiv_t		ends
00000000                      C _lldiv_t	struct
00000000                      C quot		int64_t ?
00000008                      C rem		int64_t ?
00000010                      C _lldiv_t	ends
                              C endif
                              C 
                              C ifndef _CRT_DOUBLE_DEC
 = 0                          C define _CRT_DOUBLE_DEC
                              C 
                              C ifndef _LDSUPPORT
                              C .pragma pack(push, 4)
                            * C OPTION FIELDALIGN: 4
00000000                      C _LDOUBLE struct
00000000                      C     ld	db 10 dup(?)
0000000A                      C _LDOUBLE ends
                              C .pragma pack(pop)
                              C _PTR_LD macro x
 >                            C 	exitm<x.ld>
 >                            C 	endm
                              C endif
                              C 
00000000                      C _CRT_DOUBLE struct
00000000                      C     x	real8 ?
00000008                      C _CRT_DOUBLE ends
00000000                      C _CRT_FLOAT struct
00000000                      C     f	real4 ?
00000004                      C _CRT_FLOAT ends
00000000                      C _LONGDOUBLE struct
00000000                      C     x	real10 ?
00000010                      C _LONGDOUBLE ends
                              C 
                              C .pragma pack(push,4)
                            * C OPTION FIELDALIGN: 4
00000000                      C _LDBL12 struct
00000000                      C     ld12 db 12 dup(?)
0000000C                      C _LDBL12 ends
                              C .pragma pack(pop)
                              C 
                              C endif ;; _CRT_DOUBLE_DEC
                              C 
 = 7FFF                       C RAND_MAX equ 0x7fff
                              C 
                              C ;
                              C ; Maximum number of bytes in multi-byte character in the current locale
                              C ; (also defined in ctype.h).
                              C ;
                              C ifndef MB_CUR_MAX
                              C ifdef _CRTBLD
                              C endif ; _CRTBLD
                              C if defined(1) or defined(_MSVCRT)
 = ___mb_cur_max_func()       C MB_CUR_MAX equ <___mb_cur_max_func()>
                              C endif
                              C ifndef _M_CEE_PURE
                              C externdef __mb_cur_max:int_t
                              C endif
                              C ___mb_cur_max_func proto fastcall
                              C ___mb_cur_max_l_func proto fastcall :_locale_t
                              C endif ; MB_CUR_MAX
                              C 
 = 104                        C _MAX_PATH		equ 260
 = 3                          C _MAX_DRIVE		equ 3
 = 100                        C _MAX_DIR		equ 256
 = 100                        C _MAX_FNAME		equ 256
 = 100                        C _MAX_EXT		equ 256
                              C 
 = 0                          C _OUT_TO_DEFAULT		equ 0
 = 1                          C _OUT_TO_STDERR		equ 1
 = 2                          C _OUT_TO_MSGBOX		equ 2
 = 3                          C _REPORT_ERRMODE		equ 3
                              C 
 = 1                          C _WRITE_ABORT_MSG	equ 0x1 ;; debug only, has no effect in release
 = 2                          C _CALL_REPORTFAULT	equ 0x2
                              C 
                              C ;;
                              C ;; Sizes for buffers used by the getenv/putenv family of functions.
                              C ;;
 = 7FFF                       C _MAX_ENV		equ 32767
                              C 
                              C ifndef _M_CEE_PURE
                             1C     ?_purecall_handler typedef proto fastcall 
                              C _purecall_handler typedef ptr ?_purecall_handler
                              C _set_purecall_handler	proto fastcall :_purecall_handler
                              C _get_purecall_handler	proto fastcall
                              C endif
                              C 
                              C ifndef _M_CEE_PURE
                             1C     ?_invalid_parameter_handler typedef proto fastcall :wstring_t,:wstring_t,:wstring_t,:uint_t,:uintptr_t
                              C _invalid_parameter_handler typedef ptr ?_invalid_parameter_handler
                              C _set_invalid_parameter_handler proto fastcall :_invalid_parameter_handler
                              C _get_invalid_parameter_handler proto fastcall
                              C endif
                              C 
                              C ifndef _CRT_ERRNO_DEFINED
 = 0                          C define _CRT_ERRNO_DEFINED
                              C _errno		proto fastcall
                              C _set_errno	proto fastcall :int_t
                              C _get_errno	proto fastcall :ptr int_t
                              C if defined(1) or defined(_MSVCRT)
 = errno_t ptr [_errno()]     C errno		equ <errno_t ptr [_errno()]>
                              C endif
                              C endif
                              C 
                              C __doserrno	proto fastcall
                              C _set_doserrno	proto fastcall :ulong_t
                              C _get_doserrno	proto fastcall :ptr ulong_t
                              C __sys_errlist	proto fastcall
                              C if defined(1) or defined(_MSVCRT)
 = errno_t ptr [__doserrno()  C _doserrno	equ <errno_t ptr [__doserrno()]>
   ]                            
 = __sys_errlist()            C _sys_errlist	equ <__sys_errlist()>
 = [__sys_nerr()]             C _sys_nerr	equ <[__sys_nerr()]>
                              C endif
                              C __sys_nerr	proto fastcall
                              C _dosmaperr	proto fastcall :ulong_t
                              C 
                              C if defined (_DLL) and defined (_M_IX86)
                              C endif ;; defined (_DLL) && defined (_M_IX86)
                              C 
                              C ifndef _M_CEE_PURE
                              C externdef	__argc:int_t
                              C externdef	__argv:array_t
                              C externdef	__wargv:warray_t
                              C endif
                              C 
                              C ifndef _M_CEE_PURE
                              C externdef	_environ:array_t
                              C externdef	_wenviron:warray_t
                              C externdef	_pgmptr:string_t
                              C externdef	_wpgmptr:wstring_t
                              C ifdef _CRTBLD
                              C endif
                              C endif
                              C 
                              C _get_pgmptr	proto fastcall :array_t
                              C _get_wpgmptr	proto fastcall :warray_t
                              C 
                              C if defined(SPECIAL_CRTEXE) and defined(_CRTBLD)
                              C else
                              C ifndef _M_CEE_PURE
                              C externdef	_fmode:int_t
                              C endif
                              C endif
                              C 
                              C _set_fmode	proto fastcall :int_t
                              C _get_fmode	proto fastcall :ptr int_t
                              C 
                              C ifndef _countof
 = lengthof                   C _countof	equ <lengthof>
                              C endif
                              C 
                              C ifndef _CRT_TERMINATE_DEFINED
 = 0                          C define _CRT_TERMINATE_DEFINED
                              C exit		proto fastcall :int_t
                              C _exit		proto fastcall :int_t
                              C abort		proto fastcall
                              C endif
                              C 
                              C _set_abort_behavior proto fastcall :int_t, :int_t
                              C 
                              C abs		proto fastcall :int_t
                              C labs		proto fastcall :long_t
                              C llabs		proto fastcall :int64_t
                              C _abs64		proto fastcall :int64_t
                              C 
                              C ifdef _M_CEE
                              C endif ; _M_CEE
                              C 
                              C ifdef _M_CEE_PURE
                              C else
                              C atexit		proto fastcall :ptr_t
                              C endif
                              C 
                              C atof		proto fastcall :string_t
                              C _atof_l		proto fastcall :string_t, :_locale_t
                              C atoi		proto fastcall :string_t
                              C _atoi_l		proto fastcall :string_t, :_locale_t
                              C atol		proto fastcall :string_t
                              C _atol_l		proto fastcall :string_t, :_locale_t
                              C atoll		proto fastcall :string_t
                              C _atoll_l	proto fastcall :string_t, :_locale_t
                              C 
                              C ifndef _CRT_ALGO_DEFINED
 = 0                          C define _CRT_ALGO_DEFINED
                             1C     ?LPQSORTCMD typedef proto fastcall :ptr,:ptr
                              C LPQSORTCMD typedef ptr ?LPQSORTCMD
                              C if __STDC_WANT_SECURE_LIB__
                             1C     ?_PtFuncCompare_s typedef proto fastcall :ptr,:ptr,:ptr
                              C _PtFuncCompare_s typedef ptr ?_PtFuncCompare_s
                              C bsearch_s	proto fastcall :ptr, :ptr, :size_t, :size_t, :_PtFuncCompare_s, :ptr
                              C endif
                             1C     ?_PtFuncCompare typedef proto fastcall :ptr,:ptr
                              C _PtFuncCompare typedef ptr ?_PtFuncCompare
                              C bsearch		proto fastcall :ptr, :ptr, :size_t, :size_t, :_PtFuncCompare
                              C if __STDC_WANT_SECURE_LIB__
                              C qsort_s		proto fastcall :ptr, :size_t, :size_t, :LPQSORTCMD, :ptr
                              C endif
                              C qsort		proto fastcall :ptr, :size_t, :size_t, :LPQSORTCMD
                              C endif
                              C 
                              C if 0
                              C endif
                              C 
                              C getenv		proto fastcall :string_t
                              C if __STDC_WANT_SECURE_LIB__
                              C getenv_s	proto fastcall :ptr size_t, :string_t, :size_t, :string_t
                              C endif
                              C _dupenv_s	proto fastcall :array_t, :ptr size_t, :string_t
                              C 
                              C _itoa_s		proto fastcall :int_t, :string_t, :size_t, :int_t
                              C _i64toa_s	proto fastcall :int64_t, :string_t, :size_t, :int_t
                              C _i64toa		proto fastcall :int64_t, :string_t, :int_t
                              C _ui64toa_s	proto fastcall :uint64_t, :string_t, :size_t, :int_t
                              C _ui64toa	proto fastcall :uint64_t, :string_t, :int_t
                              C _atoi64		proto fastcall :string_t
                              C _atoi64_l	proto fastcall :string_t, :_locale_t
                              C _strtoi64	proto fastcall :string_t, :array_t, :int_t
                              C _strtoi64_l	proto fastcall :string_t, :array_t, :int_t, :_locale_t
                              C _strtoui64	proto fastcall :string_t, :array_t, :int_t
                              C _strtoui64_l	proto fastcall :string_t, :array_t, :int_t, :_locale_t
                              C ldiv		proto fastcall :long_t, :long_t
                              C lldiv		proto fastcall :int64_t, :int64_t
                              C 
                              C _ltoa_s		proto fastcall :long_t, :string_t, :size_t, :int_t
                              C 
                              C mblen		proto fastcall :string_t, :size_t
                              C _mblen_l	proto fastcall :string_t, :size_t, :_locale_t
                              C _mbstrlen	proto fastcall :string_t
                              C _mbstrlen_l	proto fastcall :string_t, :_locale_t
                              C _mbstrnlen	proto fastcall :string_t, :size_t
                              C _mbstrnlen_l	proto fastcall :string_t, :size_t, :_locale_t
                              C _mbtowc_l	proto fastcall :wstring_t, :string_t, :size_t, :_locale_t
                              C mbstowcs_s	proto fastcall :ptr size_t, :wstring_t, :size_t, :string_t, :size_t
                              C 
                              C _mbstowcs_s_l	proto fastcall :ptr size_t, :wstring_t, :size_t, :string_t, :size_t, :_locale_t
                              C 
                              C mbtowc		proto fastcall :wstring_t, :string_t, :size_t
                              C mbstowcs	proto fastcall :wstring_t, :string_t, :size_t
                              C 
                              C rand		proto fastcall
                              C ifdef _CRT_RAND_S
                              C endif
                              C 
                              C _set_error_mode proto fastcall :int_t
                              C 
                              C srand		proto fastcall :uint_t
                              C strtod		proto fastcall :string_t, :array_t
                              C _strtod_l	proto fastcall :string_t, :array_t, :_locale_t
                              C strtol		proto fastcall :string_t, :array_t, :int_t
                              C _strtol_l	proto fastcall :string_t, :array_t, :int_t, :_locale_t
                              C strtoll		proto fastcall :string_t, :array_t, :int_t
                              C _strtoll_l	proto fastcall :string_t, :array_t, :int_t, :_locale_t
                              C strtoul		proto fastcall :string_t, :array_t, :int_t
                              C _strtoul_l	proto fastcall :string_t, :array_t, :int_t, :_locale_t
                              C strtoull	proto fastcall :string_t, :array_t, :int_t
                              C _strtoull_l	proto fastcall :string_t, :array_t, :int_t, :_locale_t
                              C strtold		proto fastcall :string_t, :array_t
                              C _strtold_l	proto fastcall :string_t, :array_t, :_locale_t
                              C strtof		proto fastcall :string_t, :array_t
                              C _strtof_l	proto fastcall :string_t, :array_t, :_locale_t
                              C 
                              C ifndef _MSVCRT
                              C _strtold	proto fastcall :string_t, :string_t
                              C _strtoq		proto fastcall :ptr, :string_t, :string_t
                              C strtoqd		proto fastcall :string_t, :string_t
                              C endif
                              C 
                              C ifndef _CRT_SYSTEM_DEFINED
 = 0                          C define _CRT_SYSTEM_DEFINED
                              C system		proto fastcall :string_t
                              C endif
                              C 
                              C _ultoa_s	proto fastcall :ulong_t, :string_t, :size_t, :int_t
                              C wctomb		proto fastcall :string_t, :wchar_t
                              C _wctomb_l	proto fastcall :string_t, :wchar_t, :_locale_t
                              C if __STDC_WANT_SECURE_LIB__
                              C wctomb_s	proto fastcall :ptr int_t, :string_t, :size_t, :wchar_t
                              C endif
                              C _wctomb_s_l	proto fastcall :ptr int_t, :string_t, :size_t, :wchar_t, :_locale_t
                              C wcstombs_s	proto fastcall :ptr size_t, :string_t, :size_t, :ptr wchar_t, :size_t
                              C _wcstombs_s_l	proto fastcall :ptr size_t, :string_t, :size_t, :ptr wchar_t, :size_t, :_locale_t
                              C 
                              C ifndef _CRT_ALLOCATION_DEFINED
 = 0                          C define _CRT_ALLOCATION_DEFINED
                              C calloc		proto fastcall :size_t, :size_t
                              C free		proto fastcall :ptr
                              C malloc		proto fastcall :size_t
                              C realloc		proto fastcall :ptr, :size_t
                              C _recalloc	proto fastcall :ptr, :size_t, :size_t
                              C _aligned_free	proto fastcall :ptr
                              C _aligned_malloc proto fastcall :size_t, :size_t
                              C _aligned_offset_malloc proto fastcall :size_t, :size_t, :size_t
                              C _aligned_realloc proto fastcall :ptr, :size_t, :size_t
                              C _aligned_recalloc proto fastcall :ptr, :size_t, :size_t, :size_t
                              C _aligned_offset_realloc proto fastcall :ptr, :size_t, :size_t, :size_t
                              C _aligned_offset_recalloc proto fastcall :ptr, :size_t, :size_t, :size_t, :size_t
                              C _aligned_msize	proto fastcall :ptr, :size_t, :size_t
                              C endif
                              C 
                              C ifndef _WSTDLIB_DEFINED
 = 0                          C define _WSTDLIB_DEFINED
                              C 
                              C ifndef _WCHAR_T_DEFINED
                              C endif
                              C 
                              C ifndef _WCTYPE_T_DEFINED
                              C endif
                              C 
                              C _itow		proto fastcall :int_t, :wstring_t, :int_t
                              C _itow_s		proto fastcall :int_t, :wstring_t, :size_t, :int_t
                              C _ltow		proto fastcall :int_t, :wstring_t, :int_t
                              C _ltow_s		proto fastcall :long_t, :wstring_t, :size_t,:int_t
                              C _ultow		proto fastcall :ulong_t, :warray_t, :int_t
                              C _ultow_s	proto fastcall :ulong_t, :warray_t, :size_t, :int_t
                              C wcstod		proto fastcall :wstring_t, :warray_t
                              C _wcstod_l	proto fastcall :wstring_t, :warray_t, :_locale_t
                              C wcstol		proto fastcall :wstring_t, :warray_t, :int_t
                              C _wcstol_l	proto fastcall :wstring_t, :warray_t, :int_t, :_locale_t
                              C wcstoll		proto fastcall :wstring_t, :warray_t, :int_t
                              C _wcstoll_l	proto fastcall :wstring_t, :warray_t, :int_t, :_locale_t
                              C wcstoul		proto fastcall :wstring_t, :warray_t, :int_t
                              C _wcstoul_l	proto fastcall :wstring_t, :warray_t, :int_t, :_locale_t
                              C wcstoull	proto fastcall :wstring_t, :warray_t, :int_t
                              C _wcstoull_l	proto fastcall :wstring_t, :warray_t, :int_t, :_locale_t
                              C wcstold		proto fastcall :wstring_t, :warray_t
                              C _wcstold_l	proto fastcall :wstring_t, :warray_t, :_locale_t
                              C wcstof		proto fastcall :wstring_t, :warray_t
                              C _wcstof_l	proto fastcall :wstring_t, :warray_t, :_locale_t
                              C 
                              C _wgetenv	proto fastcall :wstring_t
                              C _wgetenv_s	proto fastcall :ptr size_t, :wstring_t, :size_t, :wstring_t
                              C 
                              C _wdupenv_s	proto fastcall :warray_t, :ptr size_t, :wstring_t
                              C 
                              C ifndef _CRT_WSYSTEM_DEFINED
 = 0                          C define _CRT_WSYSTEM_DEFINED
                              C _wsystem	proto fastcall :wstring_t
                              C endif
                              C 
                              C _wtof		proto fastcall :wstring_t
                              C _wtof_l		proto fastcall :wstring_t, :_locale_t
                              C _wtoi		proto fastcall :wstring_t
                              C _wtoi_l		proto fastcall :wstring_t, :_locale_t
                              C _wtol		proto fastcall :wstring_t
                              C _wtol_l		proto fastcall :wstring_t, :_locale_t
                              C _wtoll		proto fastcall :wstring_t
                              C _wtoll_l	proto fastcall :wstring_t, :_locale_t
                              C 
                              C _i64tow_s	proto fastcall :int64_t, :wstring_t, :size_t, :int_t
                              C _i64tow		proto fastcall :int64_t, :wstring_t, :int_t
                              C _ui64tow_s	proto fastcall :uint64_t, :wstring_t, :size_t,:int_t
                              C _ui64tow	proto fastcall :uint64_t, :wstring_t, :int_t
                              C _wtoi64		proto fastcall :wstring_t
                              C _wtoi64_l	proto fastcall :wstring_t, :_locale_t
                              C _wcstoi64	proto fastcall :wstring_t, :warray_t, :int_t
                              C _wcstoi64_l	proto fastcall :wstring_t, :warray_t, :int_t, :_locale_t
                              C _wcstoui64	proto fastcall :wstring_t, :warray_t, :int_t
                              C _wcstoui64_l	proto fastcall :wstring_t, :warray_t, :int_t, :_locale_t
                              C 
                              C endif ; _WSTDLIB_DEFINED
                              C 
 = 15D                        C _CVTBUFSIZE	equ (309+40) ;; # of digits in max. dp value + slop
                              C 
                              C _fullpath	proto fastcall :string_t, :string_t, :size_t
                              C 
                              C _ecvt_s		proto fastcall :string_t, :size_t, :real8, :int_t, :ptr int_t, :ptr int_t
                              C _ecvt		proto fastcall :real8, :int_t, :ptr int_t, :ptr int_t
                              C _fcvt_s		proto fastcall :string_t, :size_t, :real8, :int_t, :ptr int_t, :ptr int_t
                              C _fcvt		proto fastcall :real8, :int_t, :ptr int_t, :ptr int_t
                              C _gcvt_s		proto fastcall :string_t, :size_t, :real8, :int_t
                              C _gcvt		proto fastcall :real8, :int_t, :string_t
                              C 
                              C _atodbl		proto fastcall :ptr _CRT_DOUBLE, :string_t
                              C _atoldbl	proto fastcall :ptr _LDOUBLE, :string_t
                              C _atoflt		proto fastcall :ptr _CRT_FLOAT, :string_t
                              C _atodbl_l	proto fastcall :ptr _CRT_DOUBLE, :string_t, :_locale_t
                              C _atoldbl_l	proto fastcall :ptr _LDOUBLE, :string_t, :_locale_t
                              C _atoflt_l	proto fastcall :ptr _CRT_FLOAT, :string_t, :_locale_t
                              C ;_lrotl		proto __cdecl :ulong_t, :int_t
                              C ;_lrotr		proto __cdecl :ulong_t, :int_t
                              C _makepath_s	proto fastcall :string_t, :size_t, :string_t, :string_t, :string_t, :string_t
                              C _makepath	proto fastcall :string_t, :string_t, :string_t, :string_t, :string_t
                              C 
                              C ifdef _M_CEE_PURE
                              C else
                              C _onexit		proto fastcall :ptr
                              C endif
                              C 
                              C ifndef _CRT_PERROR_DEFINED
 = 0                          C define _CRT_PERROR_DEFINED
                              C perror		proto fastcall :string_t
                              C endif
                              C 
                              C _putenv		proto fastcall :string_t
                              C _putenv_s	proto fastcall :string_t, :string_t
                              C 
                              C if 0 ; use intrin.inc
                              C endif
                              C 
                              C _searchenv_s	proto fastcall :string_t, :string_t, :string_t, :size_t
                              C _splitpath	proto fastcall :string_t, :string_t, :string_t, :string_t, :string_t
                              C _splitpath_s	proto fastcall :string_t, :string_t, :size_t, :string_t, :size_t, :string_t, :size_t, :string_t, :size_t
                              C _swab		proto fastcall :string_t, :string_t, :int_t
                              C 
                              C ifndef _WSTDLIBP_DEFINED
 = 0                          C define _WSTDLIBP_DEFINED
                              C 
                              C _wfullpath	proto fastcall :wstring_t, :wstring_t, :size_t
                              C _wmakepath_s	proto fastcall :wstring_t, :size_t, :wstring_t, :wstring_t, :wstring_t, :wstring_t
                              C ifndef _CRT_WPERROR_DEFINED
 = 0                          C define _CRT_WPERROR_DEFINED
                              C _wperror	proto fastcall :wstring_t
                              C endif
                              C _wputenv	proto fastcall :wstring_t
                              C _wputenv_s	proto fastcall :wstring_t, :wstring_t
                              C _wsearchenv_s	proto fastcall :wstring_t, :wstring_t, :wstring_t, :size_t
                              C 
                              C _wsplitpath	proto fastcall :wstring_t, :wstring_t, :wstring_t, :wstring_t, :wstring_t
                              C _wsplitpath_s	proto fastcall :wstring_t, :wstring_t, :size_t, :wstring_t, :size_t, :wstring_t, :size_t, :wstring_t, :size_t
                              C 
                              C endif ;; _WSTDLIBP_DEFINED
                              C 
                              C ;; The Win32 API SetErrorMode, Beep and Sleep should be used instead.
                              C _seterrormode	proto fastcall :int_t
                              C _beep		proto fastcall :ulong_t, :ulong_t
                              C _sleep		proto fastcall :ulong_t
                              C 
                              C ecvt		proto fastcall :real8, :int_t, :ptr int_t, :ptr int_t
                              C fcvt		proto fastcall :real8, :int_t, :ptr int_t, :ptr int_t
                              C gcvt		proto fastcall :real8, :int_t, :string_t
                              C itoa		proto fastcall :int_t, :string_t, :int_t
                              C ltoa		proto fastcall :long_t, :string_t, :int_t
                              C 
                              C _itoa		proto fastcall :int_t, :string_t, :int_t
                              C _ltoa		proto fastcall :long_t, :string_t, :int_t
                              C _ultoa		proto fastcall :ulong_t, :string_t, :int_t
                              C _i64toa		proto fastcall :int64_t, :string_t, :int_t
                              C _ui64toa	proto fastcall :uint64_t, :string_t, :int_t
                              C 
                              C putenv		proto fastcall :string_t
                              C 
                              C swab		proto fastcall :string_t, :string_t, :int_t
                              C ultoa		proto fastcall :ulong_t, :string_t, :int_t
                              C onexit		proto fastcall :onexit_t
                              C 
                              C ;;---
                              C 
                              C __getmainargs	proto fastcall :ptr, :ptr, :ptr, :ptr, :ptr
                              C __wgetmainargs	proto fastcall :ptr, :ptr, :ptr, :ptr, :ptr
                              C __iob_func	proto fastcall
                              C 
                              C if not defined(_MSVCRT) or defined(_CRTBLD)
                              C setargv		proto fastcall :ptr, :string_t
                              C setwargv	proto fastcall :ptr, :ptr wchar_t
                              C _atoi128	proto fastcall :string_t
                              C qsort4		proto :ptr, :size_t, :LPQSORTCMD
                              C endif
                              C 
                              C endif ; __STDLIB_INC
                              C include string.inc
                              C include inttype.inc
                              C ; INTTYPE.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ifndef __INTTYPE_INC
 = 0                          C define __INTTYPE_INC
                              C 
                              C ; assumptions:
                              C ; - [unsigned] char  is 8-bit
                              C ; - [unsigned] short is 16-bit
                              C ; - [unsigned] int   is either 16- or 32-bit
                              C ; - [unsigned] long  is either 32- or 64-bit
                              C 
                              C uint_8	 typedef byte
                              C int_8	 typedef sbyte
                              C uint_16	 typedef word
                              C int_16	 typedef sword
                              C uint_32	 typedef dword
                              C int_32	 typedef sdword
                              C uint_64	 typedef qword
                              C int_64	 typedef sqword
                              C 
                              C ; 32-bit integer format specifier
                              C ifdef __I86__
                              C else
 = ""                         C I32_SPEC equ <"">
                              C endif
                              C 
                              C ; 64-bit integer format specifier
                              C if defined(LONG_IS_64BITS) or defined(__LP64__)
                              C elseif defined(__UNIX__) or defined(__CYGWIN__) or defined(__DJGPP__)
                              C else
 = "I64"                      C I64_SPEC equ <"I64">
                              C endif
                              C 
                              C endif
                              C 
 = 0                          C define NULLC 0
                              C 
                              C ifndef __ccall
                              C ifdef _WIN64
 = fastcall                   C define __ccall <fastcall>   ; Use fastcall for -elf64
                              C endif
                              C endif
                              C 
 = 0                          C define USE_COMALLOC
 = 0                          C define USE_INDIRECTION
                              C 
 = 0                          C define OLDKEYWORDS          ; NAME, SIZE, ..
 = 0                          C define CHEXPREFIX           ; 0x prefix
                              C 
 = 800                        C define MAX_LINE_LEN         2048                ; no restriction for this number
 = 7E0                        C define MAX_STRING_LEN       MAX_LINE_LEN - 32   ; must be < MAX_LINE_LEN
 = F7                         C define MAX_ID_LEN           247                 ; must be < MAX_LINE_LEN
 = 200                        C define MAX_TOKEN            MAX_LINE_LEN / 4    ; max tokens in one line
 = 20                         C define MAX_STRUCT_ALIGN     32
 = 1000                       C define MAX_SEGMENT_ALIGN    4096
                              C 
 = 14                         C define MAX_IF_NESTING       20   ; IFxx block nesting. Must be <=32, see condasm.asm
 = 14                         C define MAX_SEG_NESTING      20   ; limit for segment nesting
 = 64                         C define MAX_MACRO_NESTING    100  ; macro call nesting
 = 20                         C define MAX_STRUCT_NESTING   32   ; limit for "anonymous structs" only
 = FF                         C define MAX_LNAME            255  ; OMF lnames - length must fit in 1 byte
 = 0                          C define LNAME_NULL           0    ; OMF first entry in lnames array
                              C 
                              C CCALLBACK macro id, arguments:VARARG
 >                            C     ?&id& typedef proto __ccall &arguments
 >                            C     exitm <id typedef ptr ?&id&>
 >                            C     endm
                              C 
                              C include ltype.inc
                              C ; LTYPE.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ifndef __LTYPE_INC
 = 0                          C define __LTYPE_INC
                              C ifndef __LIBC_INC
                              C endif
                              C 
 = 1                          C define _UPPER   0x01 ; upper case letter
 = 2                          C define _LOWER   0x02 ; lower case letter
 = 4                          C define _DIGIT   0x04 ; digit[0-9]
 = 8                          C define _SPACE   0x08 ; tab, carriage return, newline, vertical tab or form feed
 = 10                         C define _PUNCT   0x10 ; punctuation character
 = 20                         C define _CONTROL 0x20 ; control character
 = 40                         C define _LABEL   0x40 ; _UPPER + _LOWER + '@' + '_' + '$' + '?'
 = 80                         C define _HEX     0x80 ; hexadecimal digit
                              C 
                              C externdef _ltype: byte ; Label type array
                              C ifdef _WIN64
                            * C islalnum macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(byte ptr [r11+rax+1] & (_DIGIT or _UPPER or _LOWER))>
 >                          * C endm
                              C islalnum proto watcall c:byte 
                            * C islalpha macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(byte ptr [r11+rax+1] & (_UPPER or _LOWER))>
 >                          * C endm
                              C islalpha proto watcall c:byte 
                            * C islcntrl macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(byte ptr [r11+rax+1] & _CONTROL)>
 >                          * C endm
                              C islcntrl proto watcall c:byte 
                            * C isldigit macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(byte ptr [r11+rax+1] & _DIGIT)>
 >                          * C endm
                              C isldigit proto watcall c:byte 
                            * C isllower macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(byte ptr [r11+rax+1] & _LOWER)>
 >                          * C endm
                              C isllower proto watcall c:byte 
                            * C islpunct macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(byte ptr [r11+rax+1] & _PUNCT)>
 >                          * C endm
                              C islpunct proto watcall c:byte 
                            * C islspace macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(byte ptr [r11+rax+1] & _SPACE)>
 >                          * C endm
                              C islspace proto watcall c:byte 
                            * C islupper macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(byte ptr [r11+rax+1] & _UPPER)>
 >                          * C endm
                              C islupper proto watcall c:byte 
                            * C islxdigit macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(byte ptr [r11+rax+1] & _HEX)>
 >                          * C endm
                              C islxdigit proto watcall c:byte 
                            * C islabel macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(byte ptr [r11+rax+1] & _LABEL)>
 >                          * C endm
                              C islabel proto watcall c:byte 
                              C 
                            * C is_valid_id_char macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(byte ptr [r11+rax+1] & (_LABEL or _DIGIT))>
 >                          * C endm
                              C is_valid_id_char proto watcall c:byte 
                            * C is_valid_id_first_char macro _1
 >                          * C lea r11,_ltype
 >                          * C retm<((al == '.' && ModuleInfo.dotname) || (byte ptr [r11+rax+1] & _LABEL))>
 >                          * C endm
                              C is_valid_id_first_char proto watcall :byte 
                            * C is_valid_id_start macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(byte ptr [r11+rax+1] & _LABEL)>
 >                          * C endm
                              C is_valid_id_start proto watcall c:byte 
                            * C is_valid_first_char macro c
 >                          * C lea r11,_ltype
 >                          * C retm<(al == '.' || (byte ptr [r11+rax+1] & _LABEL))>
 >                          * C endm
                              C is_valid_first_char proto watcall c:byte 
                            * C ltokstart macro string
 >                          * C lea r11,_ltype
 >                          * C movzx eax,byte ptr [rcx]
 >                          * C .while ( (byte ptr [r11+rax+1] & _SPACE) )
 >                          * C inc rcx
 >                          * C mov al,[rcx]
 >                          * C .endw
 >                          * C xchg rax,rcx
 >                          * C exitm<>
 >                          * C endm
                              C ltokstart proto fastcall string:string_t 
                              C endif
                              C 
                            * C islascii macro c
 >                          * C retm<(al !< 128)>
 >                          * C endm
                              C islascii proto watcall c:byte 
                              C 
                            * C islprint macro c
 >                          * C retm<(al !>= 0x20 && al !<= 0x7e)>
 >                          * C endm
                              C islprint proto watcall c:byte 
                              C 
                            * C islgraph macro c
 >                          * C retm<(al !>= 0x21 && al !<= 0x7e)>
 >                          * C endm
                              C islgraph proto watcall c:byte 
                              C 
                              C endif
                              C include token.inc
                              C ; TOKEN.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ifndef __TOKEN_INC
 = 0                          C define __TOKEN_INC
                              C 
                              C ; T_INSTRUCTION - T_RES_ID are reserved words.
                              C ; T_REG - T_RES_ID match RWT_REG - RWT_RES_ID
                              C 
 = 0                          C T_FINAL             equ 0
 = 1                          C T_INSTRUCTION       equ 1       ; 1
 = 2                          C T_REG               equ 2       ; 2 (==RWT_REG)
 = 3                          C T_DIRECTIVE         equ 3       ; 3 (==RWT_DIRECTIVE)
 = 4                          C T_UNARY_OPERATOR    equ 4       ; 4 (==RWT_UNARY_OP)
 = 5                          C T_BINARY_OPERATOR   equ 5       ; 5 (==RWT_BINARY_OP)
 = 6                          C T_STYPE             equ 6       ; 6 (==RWT_STYPE)
 = 7                          C T_RES_ID            equ 7       ; 7 (==RWT_RES_ID)
 = 8                          C T_ID                equ 8       ; 8
 = 9                          C T_STRING            equ 9       ; 9
 = A                          C T_NUM               equ 10      ; A
 = B                          C T_FLOAT             equ 11      ; B
 = C                          C T_BAD_NUM           equ 12      ; C
 = D                          C T_DBL_COLON         equ 13      ; D
                              C 
 = 28                         C T_OP_BRACKET        equ '('
 = 5B                         C T_OP_SQ_BRACKET     equ '['
 = 29                         C T_CL_BRACKET        equ ')'
 = 5D                         C T_CL_SQ_BRACKET     equ ']'
 = 2C                         C T_COMMA             equ ','
 = 3A                         C T_COLON             equ ':'
 = 2E                         C T_DOT               equ '.'
 = 3F                         C T_QUESTION_MARK     equ '?'
 = 25                         C T_PERCENT           equ '%'
                              C 
 = 1                          C T_HLL_DELAY         equ 0x01    ; [0]: ELSEIF/WHILE/CASE
 = 2                          C T_HLL_MACRO         equ 0x02    ; -- macro(args)
 = 4                          C T_HLL_PROC          equ 0x04    ; -- proc(args)
 = 8                          C T_HLL_DELAYED       equ 0x08    ; [0]: delayed
 = 10                         C T_EVEX_OPT          equ 0x10    ; {T_STRING} -- {k1}{z}..
 = 20                         C T_HLL_DBLCOLON      equ 0x20
 = 40                         C T_EXPR              equ 0x40
                              C 
                              C .template asm_tok watcall
00000000                    * C asm_tok struct
00000000                      C     token               uchar_t ?
00000001                      C     union
00000000                      C      dirtype            uchar_t ?   ; T_DIRECTIVE: type
00000000                      C      bytval             uchar_t ?   ; T_STYPE: memtype
00000000                      C      precedence         uchar_t ?   ; T_UNARY_OPERATOR/T_BINARY_OPERATOR
00000000                      C      string_delim       char_t ?    ; T_STRING: string delimiter
00000000                      C      floattype          char_t ?    ; T_FLOAT: 0 or 'r'
00000000                      C      numbase            char_t ?    ; T_NUM: number base
00000000                      C      specval            char_t ?    ; 1-byte special tokens: flags
00000001                      C     ends
00000002                      C     hll_flags           uchar_t ?   ; xx( if xx == macro/proc/label()
00000003                      C     hll_index           uchar_t ?
00000004                      C     union
00000000                      C      tokval             uint_t ?    ; index if token is a reserved word
00000000                      C      stringlen          uint_t ?    ; T_STRING: size
00000000                      C      idarg              uint_t ?    ; T_ID: currently not used
00000000                      C      itemlen            uint_t ?    ; T_NUM: size
00000000                      C      lastidx            uint_t ?    ; T_FINAL: last index (used in RunMacro())
00000004                      C     ends
00000008                      C     string_ptr          string_t ?
00000010                      C     tokpos              string_t ?  ; points to item in CurrSource
                              C 
                              C    .inline tokptr :int_t
                            * C tokptr proc watcall :int_t
00000018                    * C asm_tok ends
00000000                    * C asm_tokVtbl struct
                            * C T$0001 typedef proto watcall :ptr, :int_t
                            * C P$0001 typedef ptr T$0001
00000000                    * C tokptr P$0001 ?
                            * C asm_tok_tokptr macro this, _1
 >                          * C imul    edx,edx,asm_tok
 >                          * C add     rax,rdx
 >                          * C exitm<>
 >                          * C endm
                              C    .ends
00000008                    * C asm_tokVtbl ends
                              C     token_t typedef ptr asm_tok
                              C 
                              C endif
                              C include symbols.inc
                              C ; SYMBOLS.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ifndef __SYMBOLS_INC
 = 0                          C define __SYMBOLS_INC
                              C 
                              C ; defines symbol structures asym and dsym,
                              C ; and prototypes of functions in symbols.c.
                              C ; This file is included by parser.inc
                              C 
                              C ; SYM_LIB  - library paths are no longer added to the symbol table
                              C ; SYM_LNAME has been removed. It was used for the null-entry in the LNAME table only
                              C ; v2.01: SYM_PROC has been removed.
                              C ; v2.01: SYM_LIB has been removed.
                              C 
                              C .enum sym_state {
                            * C sym_state typedef sdword
 = 0                        * C SYM_UNDEFINED equ 0x0
 = 1                        * C SYM_INTERNAL equ 0x1
 = 2                        * C SYM_EXTERNAL equ 0x2
 = 3                        * C SYM_SEG equ 0x3
 = 4                        * C SYM_GRP equ 0x4
 = 5                        * C SYM_STACK equ 0x5
 = 6                        * C SYM_STRUCT_FIELD equ 0x6
 = 7                        * C SYM_TYPE equ 0x7
 = 8                        * C SYM_ALIAS equ 0x8
 = 9                        * C SYM_MACRO equ 0x9
 = A                        * C SYM_TMACRO equ 0xA
 = B                        * C SYM_CLASS_LNAME equ 0xB
                              C 
                              C ; v2.04: MT_SHORT removed
                              C ; v2.07: MT_ABS (0xC2) removed
                              C 
 = 1F                         C MT_SIZE_MASK            equ 0x1F ; if MT_SPECIAL==0 then bits 0-4 = size - 1
 = 20                         C MT_FLOAT                equ 0x20 ; bit 5=1
 = 40                         C MT_SIGNED               equ 0x40 ; bit 6=1
 = 0                          C MT_BYTE                 equ 1 - 1
 = 40                         C MT_SBYTE                equ MT_BYTE or MT_SIGNED
 = 1                          C MT_WORD                 equ 2 - 1
 = 41                         C MT_SWORD                equ MT_WORD or MT_SIGNED
 = 21                         C MT_REAL2                equ MT_WORD or MT_FLOAT
 = 3                          C MT_DWORD                equ 4 - 1
 = 43                         C MT_SDWORD               equ MT_DWORD or MT_SIGNED
 = 23                         C MT_REAL4                equ MT_DWORD or MT_FLOAT
 = 5                          C MT_FWORD                equ 6 - 1
 = 7                          C MT_QWORD                equ 8 - 1
 = 47                         C MT_SQWORD               equ MT_QWORD or MT_SIGNED
 = 27                         C MT_REAL8                equ MT_QWORD or MT_FLOAT
 = 9                          C MT_TBYTE                equ 10 - 1
 = 29                         C MT_REAL10               equ MT_TBYTE or MT_FLOAT
 = F                          C MT_OWORD                equ 16 - 1
 = 2F                         C MT_REAL16               equ MT_OWORD or MT_FLOAT
 = 1F                         C MT_YMMWORD              equ 32 - 1
 = 3F                         C MT_ZMMWORD              equ 64 - 1
 = 1F                         C MT_YWORD                equ MT_YMMWORD
 = 3F                         C MT_ZWORD                equ MT_ZMMWORD
 = 80                         C MT_PROC                 equ 0x80 ; symbol is a TYPEDEF PROTO, state=SYM_TYPE,
                              C                                  ; typekind=TYPE_TYPEDEF, prototype is stored in target_type
 = 81                         C MT_NEAR                 equ 0x81
 = 82                         C MT_FAR                  equ 0x82
 = C0                         C MT_EMPTY                equ 0xC0
 = C1                         C MT_BITS                 equ 0xC1 ; record field
 = C2                         C MT_ABS                  equ 0xC2 ; v2.31: macro/proto imm param
 = C3                         C MT_PTR                  equ 0xC3 ; v2.05: changed, old value 0x83
 = C4                         C MT_TYPE                 equ 0xC4 ; symbol has user-defined type (struct, union, record)
 = 80                         C MT_SPECIAL              equ 0x80 ; bit 7
 = C0                         C MT_SPECIAL_MASK         equ 0xC0 ; bit 6+7
 = 80                         C MT_ADDRESS              equ 0x80 ; bit 7=1, bit 6 = 0
                              C 
                            * C IS_SIGNED macro _1
 >                          * C and al,MT_SPECIAL_MASK
 >                          * C retm<(al == MT_SIGNED)>
 >                          * C endm
                              C IS_SIGNED proto watcall :byte 
                              C 
                              C ; symbols can be
                              C ; - "labels" (data or code, internal, external, stack)
                              C ;   mem_type is MT_BYTE..MT_OWORD, MT_NEAR, MT_FAR, MT_PTR
                              C ; - constants (EQU) or assembly time variables ("="),
                              C ;   mem_type "usually" is MT_EMPTY.
                              C ; - types (STRUCT, UNION, TYPEDEF, RECORD), mem_type = MT_TYPE
                              C ; - preprocessor items (macros and text macros), which have no
                              C ;   mem_type (MT_EMPTY).
                              C 
                              C .template debug_info
00000000                    * C debug_info struct
00000000                      C     start_line      dd ? ; procs's start line
00000004                      C     end_line        dd ? ; procs's last line
00000008                      C     ln_fileofs      dd ? ; file offset to line numbers
0000000C                      C     line_numbers    dw ? ; line numbers in function
0000000E                      C     file            dw ? ; proc's start file
00000010                      C     next_proc       dd ? ; index next proc
00000014                      C     next_file       dd ? ; index next file
                              C    .ends
00000018                    * C debug_info ends
                              C     debug_t         typedef ptr debug_info
                              C 
                              C 
 = 1                          C S_USED          equ 0x01 ; flags
 = 2                          C S_ISDEFINED     equ 0x02
 = 4                          C S_SCOPED        equ 0x04
 = 8                          C S_IAT_USED      equ 0x08
 = 10                         C S_ISEQUATE      equ 0x10
 = 20                         C S_PREDEFINED    equ 0x20
 = 40                         C S_VARIABLE      equ 0x40
 = 80                         C S_ISPUBLIC      equ 0x80
                              C 
 = 1                          C S_LIST          equ 0x01 ; flag1
 = 2                          C S_ISARRAY       equ 0x02
 = 4                          C S_ISDATA        equ 0x04
 = 8                          C S_ISPROC        equ 0x08
 = 10                         C S_ISSAVED       equ 0x10
 = 20                         C S_FWDREF        equ 0x20
 = 40                         C S_INCLUDED      equ 0x40
 = 80                         C S_METHOD        equ 0x80
                              C 
 = 1                          C S_CLASS         equ 0x01 ; flag2
 = 2                          C S_VTABLE        equ 0x02 ; base class - first member = lpVtbl
 = 4                          C S_ISVTABLE      equ 0x04 ; vtable struct - classVtbl
 = 8                          C S_VMACRO        equ 0x08 ; vtable method is inline - sym->vmacro set
 = 10                         C S_ISINLINE      equ 0x10 ; v2.31.24: SYM_EXTERNAL.target_type == SYM_MACRO
 = 20                         C S_ISSTATIC      equ 0x20 ; v2.32.26: SYM_EXTERNAL.target_type == SYM_MACRO
 = 40                         C S_VPARRAY       equ 0x40 ; p.p.proc() -- nested function call
 = 80                         C S_OPERATOR      equ 0x80
                              C 
 = 1                          C S_ISCOM         equ 0x01 ; sflags
 = 2                          C S_WEAK          equ 0x02
 = 4                          C S_ISVARARG      equ 0x04
 = 8                          C S_ISVECTOR      equ 0x08
                              C 
 = 1                          C M_ISVARARG      equ 0x01 ; mac_flag
 = 2                          C M_ISFUNC        equ 0x02
 = 4                          C M_LABEL         equ 0x04
 = 8                          C M_MULTILINE     equ 0x08
 = 10                         C M_PURGED        equ 0x10
                              C 
                              C .template asym
00000000                    * C asym struct
00000000                      C     nextitem        ptr asym ?      ; next symbol in hash line
00000008                      C     name            string_t ?      ; symbol name
00000010                      C     name_size       int_t ?
00000014                      C     state           uchar_t ?
00000015                      C     mem_type        uchar_t ?
00000016                      C     langtype        uchar_t ?
00000017                      C     flags           uchar_t ?       ; bitfield
00000018                      C     flag1           uchar_t ?
00000019                      C     flag2           uchar_t ?
0000001A                      C     segoffsize      uchar_t ?
0000001B                      C     is_far          uchar_t ?
00000020                      C     type            ptr asym ?      ; set if memtype is MT_TYPE
                              C 
00000028                      C     union
00000000                      C      offs           int_t ?         ; used by SYM_INTERNAL (labels), SYM_TYPE, SYM_STACK, SYM_SEG
00000000                      C      value          int_t ?         ; used by SYM_INTERNAL (equates)
00000000                      C      uvalue         uint_t ?        ; v2.01: equates (they are 33-bit!)
00000000                      C      string_ptr     string_t ?      ; used by SYM_TMACRO
00000000                      C      substitute     ptr asym ?      ; v2.04b: used by SYM_ALIAS
                              C      ;
                              C      ; used by SYM_MACRO if predefined==1
                              C      ;
                              C      func_ptr       proc local fastcall :ptr macro_instance, :string_t, :ptr asm_tok
                            * C T$0002 typedef proto fastcall :ptr macro_instance, :string_t, :ptr asm_tok
                            * C P$0002 typedef ptr T$0002
00000000                    * C func_ptr P$0002 ?
00000000                      C      classlnameidx  int_t ?         ; used by SYM_CLASS_LNAME
00000008                      C     ends
                              C 
00000030                      C     union
00000000                      C      segm           ptr asym ?      ; used by SYM_INTERNAL, SYM_EXTERNAL
00000000                      C      class          ptr asym ?      ; used by SYM_TYPE
00000000                      C      vtable         ptr asym ?      ; used by SYM_TYPE
00000000                      C      vmacro         ptr asym ?      ; used by SYM_TYPE
00000008                      C     ends
                              C 
00000038                      C     union
                              C      ;
                              C      ; for SYM_INTERNAL (data labels, memtype != NEAR|FAR), SYM_STRUCT_FIELD
                              C      ; size of 1st initializer's dimension in bytes
                              C      ;
00000000                      C      first_size     uint_t ?
                              C      ;
                              C      ; for SYM_INTERNAL (memtype == NEAR|FAR),
                              C      ; SYM_GRP (Ofssize),
                              C      ; SYM_EXTERNAL (Ofssize, comm, weak, isfar, is_ptr, ptr_memtype),
                              C      ; SYM_STACK (Ofssize, isfar, is_vararg, is_ptr, ptr_memtype ),
                              C      ; SYM_TYPE, TYPE_TYPEDEF (Ofssize, isfar, is_ptr, ptr_memtype )
                              C      ;
00000004                      C      struct
00000000                      C       Ofssize       uchar_t ?       ; offset size (USE16, USE32)
00000001                      C       is_ptr        uchar_t ?       ; PTR indirection
00000002                      C       union
00000000                      C        ptr_memtype  uchar_t ?       ; pointer target type
00000000                      C        asmpass      uchar_t ?       ; SYM_INTERNAL (mem_type NEAR|FAR)
00000001                      C       ends
00000003                      C      sflags         uchar_t ?
00000004                      C      ends
00000000                      C      mac_flag       uchar_t ?       ; for SYM_MACRO -- byte
00000004                      C     ends
                              C 
0000003C                      C     union
                              C      ;
                              C      ; for SYM_INTERNAL (data labels only), SYM_STRUCT_FIELD
                              C      ; size of 1st initializer's dimension in item units
                              C      ;
00000000                      C      first_length   uint_t ?
                              C      ;
                              C      ; SYM_TYPE (TYPEKIND_STRUCT or TYPEKIND_UNION)
                              C      ; max size members
                              C      ;
00000000                      C      max_mbr_size   uint_t ?
                              C      ;
                              C      ; SYM_STACK, SYM_TYPE (TYPEKIND_TYPEDEF), SYM_EXTERNAL,
                              C      ; SYM_INTERNAL (code labels)
                              C      ; set if ptr_memtype is MT_TYPE
                              C      ;
00000000                      C      target_type    ptr asym ?
00000008                      C     ends
                              C     ;
                              C     ; SYM_TMACRO (if it's a register variable for FASTCALL)
                              C     ;
00000048                      C     regist          ushort_t 2 dup(?)
                              C 
0000004C                      C     union
                              C      ;
                              C      ; for SYM_INTERNAL, SYM_STRUCT_FIELD, SYM_TYPE, SYM_STACK, SYM_EXTERNAL (comm=1)
                              C      ; SYM_TMACRO: size of buffer allocated for the text in string_ptr
                              C      ; total number of bytes (sizeof)
                              C      ;
00000000                      C      total_size     uint_t ?
                              C      ;
                              C      ; for SYM_INTERNAL, isequate=1 (numeric equates)
                              C      ; high bits for equates
                              C      ;
00000000                      C      value3264      int_t ?
00000000                      C      dll            ptr dll_desc ? ; SYM_EXTERNAL (isproc=1)
                              C      ;
                              C      ; for SYM_SEG offset field contain "local start offset" (=0)
                              C      ; SYM_INTERNAL, SYM_STRUCT_FIELD, SYM_STACK, SYM_EXTERNAL (comm==1):
                              C      ;
00000000                      C      max_offset     int_t ?
00000008                      C     ends
                              C 
00000058                      C     union
00000000                      C      total_length   uint_t ?        ; total number of elements (LENGTHOF)
00000000                      C      altname        ptr asym ?      ; SYM_EXTERNAL (comm==0): alternative name
00000000                      C      debuginfo      ptr debug_info ?; SYM_INTERNAL (isproc==1): debug info (COFF)
                              C                                     ; SYM_INTERNAL+predefined
                              C      sfunc_ptr      proc local fastcall :ptr asym, :ptr
                            * C T$0003 typedef proto fastcall :ptr asym, :ptr
                            * C P$0003 typedef ptr T$0003
00000000                    * C sfunc_ptr P$0003 ?
00000008                      C      struct                         ; SYM_TYPE
00000000                      C       cvtyperef     ushort_t ?      ; codeview type index (used after assembly steps)
00000002                      C       typekind      ushort_t ?      ; v2.04: moved from first_length, were it didn't work anymore
00000004                      C      ends                           ; since the addition of field max_mbr_size.
00000008                      C     ends
00000060                      C     union                           ; SYM_INTERNAL, SYM_UNDEFINED, SYM_EXTERNAL: backpatching fixup
00000000                      C      bp_fixup       ptr fixup ?
00000000                      C      ext_idx        uint_t ?        ; for SYM_EXTERNAL: table index ( for coff and elf )
00000008                      C      struct                         ; omf indices are 16-bit only!
00000000                      C       ext_idx1      ushort_t ?      ; omf: (external definition) index
00000002                      C       ext_idx2      ushort_t ?      ; omf: (external definition) index for weak external
00000004                      C      ends
00000008                      C     ends
                              C    .ends
00000068                    * C asym ends
                              C     asym_t          typedef ptr asym
                              C 
                              C 
                              C ;---------------------------------------------------------------------------
                              C ; Structures for grpdef, segdef, externdef, pubdef, included library,
                              C ; procedure and symbolic integer constants.
                              C ;---------------------------------------------------------------------------
                              C 
                              C .template seg_item
00000000                    * C seg_item struct
00000000                      C     next            ptr seg_item ?
00000008                      C     iseg            ptr dsym ?
                              C    .ends
00000010                    * C seg_item ends
                              C     segitem_t       typedef ptr seg_item
                              C 
                              C .template grp_info
00000000                    * C grp_info struct
00000000                      C     seglist         ptr seg_item ?  ; list of segments in the group
00000008                      C     grp_idx         int_t ?         ; its group index (OMF)
0000000C                      C     lname_idx       int_t ?         ; LNAME index (OMF only)
00000010                      C     numseg          uint_t ?        ; OMF: number of segments in the group
                              C    .ends
00000018                    * C grp_info ends
                              C     group_t         typedef ptr grp_info
                              C 
                              C .template seg_info
00000000                    * C seg_info struct
00000000                      C     sgroup          ptr asym ?  ; segment's group or NULL
00000008                      C     start_loc       uint_t ?    ; starting offset of current ledata or lidata
0000000C                      C     union
00000000                      C      current_loc    uint_t ?    ; current offset in current ledata or lidata
00000000                      C      reloc_offset   uint_t ?    ; ELF: reloc file offset
00000000                      C      start_offset   uint_t ?    ; BIN: start offset in group
00000004                      C     ends
00000010                      C     CodeBuffer      string_t ?  ;
00000018                      C     bytes_written   uint_t ?    ; initialized bytes in segment
0000001C                      C     union
00000000                      C      label_list     asym_t ?    ; linked list of labels in this seg
                              C      flushfunc      proc local fastcall :ptr dsym, :ptr byte, :dword, :ptr
                            * C T$0004 typedef proto fastcall :ptr dsym, :ptr byte, :dword, :ptr
                            * C P$0004 typedef ptr T$0004
00000000                    * C flushfunc P$0004 ?
00000008                      C     ends
00000028                      C     head            ptr fixup ? ; fixup queue head
00000030                      C     tail            ptr fixup ? ; fixup queue tail
00000038                      C     union
00000000                      C      LinnumQueue    ptr_t ?     ; for COFF line numbers
00000000                      C      fileoffset     uint_t ?    ; used by BIN + ELF
00000000                      C      num_linnums    uint_t ?    ; used by COFF (after LinnumQueue has been read)
00000008                      C     ends
00000040                      C     num_relocs      uint_t ?    ; used by COFF/ELF
00000044                      C     seg_idx         uint_t ?    ; segment #; v2.12: changed from short to unsigned
00000048                      C     segtype         uint_t ?    ; segment's type (code, data, ...)
0000004C                      C     lname_idx       int_t ?     ; segment's name LNAME index (OMF only)
00000050                      C     clsym           ptr asym ?  ; segment's class name (stored in an asym item)
00000058                      C     union
00000000                      C      abs_frame      uint_t ?    ; ABS seg, frame number (OMF,BIN)
00000000                      C      comdat_number  uint_t ?    ; associated COMDAT segno (COFF)
00000000                      C      comdat_idx     uint_t ?    ; lname index of COMDAT symbol (OMF)
00000004                      C     ends
0000005C                      C     union
00000000                      C      abs_offset     uint_t ?    ; ABS seg, offset (OMF only)
00000000                      C      aliasname      string_t ?  ; ALIAS name (COFF/ELF only)
00000008                      C     ends
00000068                      C     Ofssize         uchar_t ?   ; segment's offset size
00000069                      C     characteristics uchar_t ?   ; used by COFF/ELF/PE
0000006A                      C     alignment       uchar_t ?   ; is value 2^x
0000006B                      C     readonly        uchar_t ?   ; if segment is readonly
0000006C                      C     info            uchar_t ?   ; if segment is info only (COFF/ELF)
0000006D                      C     force32         uchar_t ?   ; force 32bit segdef (OMF only)
0000006E                      C     data_in_code    uchar_t ?   ; data items in code segm (OMF only)
0000006F                      C     internal        uchar_t ?   ; internal segment with private buffer
00000070                      C     written         uchar_t ?   ; code/data just written
00000071                      C     linnum_init     uchar_t ?   ; v2.10: linnum data emitted for segment?
00000072                      C     combine         uchar_t ?   ; combine type, see omfspec.inc
00000073                      C     comdatselection uchar_t ?   ; if > 0, it's a COMDAT (COFF/OMF)
                              C    .ends
00000078                    * C seg_info ends
                              C     segment_t       typedef ptr seg_info
                              C 
 = FF                         C MAX_SEGALIGNMENT equ 0xFF
                              C 
                              C ; PROC item
                              C 
 = 1                          C PROC_HAS_VARARG equ 0x01        ; last param is VARARG
 = 2                          C PROC_PE_TYPE    equ 0x02        ; prolog-epilog type, 1=use LEAVE
 = 4                          C PROC_ISEXPORT   equ 0x04        ; EXPORT attribute set
 = 8                          C PROC_FORCEFRAME equ 0x08        ; FORCEFRAME prologuearg?
 = 10                         C PROC_LOADDS     equ 0x10        ; LOADDS prologuearg?
 = 20                         C PROC_STACKPARAM equ 0x20        ; 1=stack params exists ( not just register params )
 = 40                         C PROC_ISFRAME    equ 0x40        ; FRAME attribute set?
 = 80                         C PROC_FPO        equ 0x80
                              C 
                              C .template proc_info
00000000                    * C proc_info struct
00000000                      C     regslist        ptr word ?      ; list of registers to be saved
00000008                      C     paralist        ptr dsym ?      ; list of parameters
00000010                      C     locallist       ptr dsym ?      ; list of local variables
00000018                      C     labellist       ptr dsym ?      ; list of local labels
00000020                      C     parasize        uint_t ?        ; total no. of bytes used by parameters
00000024                      C     localsize       uint_t ?        ; total no. of bytes used by local variables
00000028                      C     prologuearg     string_t ?      ; prologuearg attribute
00000030                      C     exc_handler     ptr asym ?      ; exc handler set by FRAME
00000038                      C     ReservedStack   int_t ?         ; win64: additional reserved stack
0000003C                      C     prolog_list_pos uint_t ?        ; prologue list pos
00000040                      C     flags           uchar_t ?
00000041                      C     size_prolog     uchar_t ?       ; v2.10: prologue size
00000042                      C     basereg         ushort_t ?      ; v2.11: stack base register
                              C    .ends
00000048                    * C proc_info ends
                              C     proc_t          typedef ptr proc_info
                              C 
                              C ; macro parameter
                              C 
                              C .template mparm_list
00000000                    * C mparm_list struct
00000000                      C     deflt           string_t ?      ; optional default parm
00000008                      C     required        uchar_t ?       ; is parm required (REQ)
                              C    .ends
00000010                    * C mparm_list ends
                              C     mparm_t         typedef ptr mparm_list
                              C 
                              C ; macro line
                              C 
                              C .template srcline
00000000                    * C srcline struct
00000000                      C     next            ptr srcline ?
00000008                      C     ph_count        uchar_t ?       ; placeholders contained in this line
00000009                      C     line            char_t 1 dup(?)
                              C    .ends
00000010                    * C srcline ends
                              C     srcline_t       typedef ptr srcline
                              C 
                              C ; macro item
                              C 
                              C .template macro_info
00000000                    * C macro_info struct
00000000                      C     parmcnt         ushort_t ?      ; no of params
00000002                      C     union
00000000                      C      localcnt       ushort_t ?      ; no of locals
00000000                      C      autoexp        ushort_t ?      ; auto-expansion flags if predefined macro
00000002                      C     ends
00000008                      C     parmlist        ptr mparm_list ?; array of parameter items
00000010                      C     lines           ptr srcline ?   ; prepared macro source lines
00000018                      C     srcfile         uint_t ?        ; sourcefile index
                              C    .ends
00000020                    * C macro_info ends
                              C 
                              C ; STRUCT field
                              C 
                              C .template sfield : public asym      ; field symbol ( state=SYM_STRUCT_FIELD )
00000000                    * C sfield struct
00000000                    * C asym <>
00000068                      C     next            ptr sfield ?    ; next field in STRUCT,UNION,RECORD
00000070                      C     ivalue          char_t ?        ; v2.09: type changed from char * to char[]
                              C    .ends
00000078                    * C sfield ends
                              C 
 = 0                          C TYPE_NONE       equ 0
 = 1                          C TYPE_STRUCT     equ 1
 = 2                          C TYPE_UNION      equ 2
 = 3                          C TYPE_TYPEDEF    equ 3
 = 4                          C TYPE_RECORD     equ 4
                              C 
 = 1                          C SI_ISINLINE     equ 1               ; STRUCT/UNION: inline (unused)
 = 2                          C SI_ISOPEN       equ 2               ; STRUCT/UNION: set until the matching ENDS is found
 = 4                          C SI_ORGINSIDE    equ 4               ; STRUCT: struct contains an ORG
                              C 
                              C .template struct_info
00000000                    * C struct_info struct
00000000                      C     head            ptr sfield ?    ; STRUCT/UNION/RECORD: start of field list
00000008                      C     tail            ptr sfield ?    ; STRUCT/UNION/RECORD: current/next field
00000010                      C     alignment       uchar_t ?       ; STRUCT: 1,2,4,8,16 or 32
00000011                      C     flags           uchar_t ?
                              C    .ends
00000018                    * C struct_info ends
                              C 
                              C ; dsym originally was a "directive_node"
                              C ; However, currently all symbols except SYM_STRUCT_FIELDs are allocated as a dsym.
                              C ; the additional 3 fields are used differently depending on symbol's type.
                              C 
                              C .template dsym : public asym
00000000                    * C dsym struct
00000000                    * C asym <>
                              C 
00000068                      C     union
00000000                      C      seginfo        ptr seg_item ?  ; SYM_SEG (segments)
00000000                      C      grpinfo        ptr grp_info ?  ; SYM_GRP (groups)
00000000                      C      procinfo       ptr proc_info ? ; SYM_INTERNAL|SYM_EXTERNAL (procs, isproc=1)
00000000                      C      structinfo     ptr struct_info ?; SYM_TYPE (structs, unions, records [, typedefs])
00000000                      C      macroinfo      ptr macro_info ?; SYM_MACRO (macros)
00000000                      C      nextll         ptr dsym ?      ; SYM_STACK, SYM_INTERNAL (code labels, isproc=0)
00000008                      C     ends                            ; used to save the local hash table (contains
                              C                                     ; PROC locals: params, locals, labels). Details
                              C                                     ; see SymGetLocal(), SymSetLocal() in symbols.asm
                              C 
00000070                      C     next            ptr dsym ?      ; next item in linked lists of certain symbol types.
                              C                                     ; - SYM_UNDEFINED -> TAB_UNDEF
                              C                                     ; - SYM_EXTERNAL  -> TAB_EXT
                              C                                     ; - SYM_SEG       -> TAB_SEG
                              C                                     ; - SYM_GRP       -> TAB_GRP
                              C                                     ; - SYM_ALIAS:    -> TAB_ALIAS
                              C                                     ; for SYM_INTERNAL:
                              C                                     ; linked list of labels for current segment
                              C                                     ; (used for BackPatch)
                              C 
                              C ; for SYM_UNDEFINED, SYM_EXTERNAL, SYM_ALIAS and SYM_GRP:
                              C ; predecessor of current symbol with the same state, to allow fast removes.
                              C ; Actually, the only symbols which may change the state and thus
                              C ; have a chance to be removed are SYM_UNDEFINED and SYM_EXTERNAL ( weak=TRUE )
                              C ; during pass one.
                              C 
00000078                      C     union
00000000                      C      prev           ptr dsym ?      ; used by PROC symbols (SYM_INTERNAL) for linked list, TAB_PROC
00000000                      C      nextproc       ptr dsym ?      ; used by PROC locals (SYM_STACK) for linked list
00000000                      C      nextlocal      ptr dsym ?      ; used by PROC params (SYM_STACK) for linked list
00000000                      C      nextparam      ptr dsym ?      ; used by SYM_EXTERNAL (weak=FALSE) if altname is set
00000008                      C     ends
                              C    .ends
00000080                    * C dsym ends
                              C     dsym_t          typedef ptr dsym
                              C 
                              C SymAlloc        proto fastcall :string_t
                              C SymFree         proto fastcall :ptr asym
                              C SymCreate       proto fastcall :string_t
                              C SymLCreate      proto fastcall :string_t
                              C SymAddGlobal    proto fastcall :ptr asym
                              C SymAddLocal     proto fastcall :ptr asym, :string_t
                              C SymLookup       proto fastcall :string_t
                              C SymLookupLocal  proto fastcall :string_t
                              C SymFind         proto fastcall :string_t
                              C 
                              C SymSearch macro x
 >                            C     exitm<SymFind(x)>
 >                            C     endm
                              C 
                              C SymInit         proto fastcall
                              C SymPassInit     proto fastcall :int_t
                              C SymMakeAllSymbolsPublic proto fastcall
                              C SymGetAll       proto fastcall :ptr ptr asym
                              C SymEnum         proto fastcall :ptr asym, :ptr int_t
                              C SymGetCount     proto fastcall
                              C 
                              C StrCmpFunc_t    typedef proto fastcall :ptr, :ptr, :size_t
                              C StrCmpFunc      typedef ptr StrCmpFunc_t
                              C 
                              C externdef       SymCmpFunc:StrCmpFunc
                              C 
                              C SymSetCmpFunc   proto fastcall
                              C SymClearLocal   proto fastcall
                              C SymSetLocal     proto fastcall :ptr asym
                              C SymGetLocal     proto fastcall :ptr asym
                              C 
                              C endif
                              C include errmsg.inc      ; must be located AFTER #defines lines
                              C ; ERRMSG.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; Assembler message output interface.
                              C ; This file is included by asmc.inc.
                              C ;
                              C ifndef __ERRMSG_INC
 = 0                          C define __ERRMSG_INC
                              C 
 = stdout                     C define errout <stdout>
                              C 
 = 0                          C define NOTE_INCLUDED_BY 0
 = 1                          C define NOTE_MACRO_CALLED_FROM 1
 = 2                          C define NOTE_ITERATION_MACRO_CALLED_FROM 2
 = 3                          C define NOTE_MAIN_LINE_CODE 3
                              C 
                              C PrintNote   proto fastcall :int_t, :vararg
                              C ErrnoStr    proto fastcall
                              C WriteError  proto fastcall
                              C 
                              C endif
                              C include queue.inc
                              C ; QUEUE.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; interface for queue.asm
                              C ; This file is included by asmc.inc
                              C ;
                              C ifndef __QUEUE_INC
 = 0                          C define __QUEUE_INC
                              C 
00000000                      C qnode	struct
00000000                      C next	ptr ?
00000008                      C union
00000000                      C  elmt	ptr ?
00000000                      C  sym	ptr asym ?
00000008                      C ends
00000010                      C qnode	ends
                              C qnode_t typedef ptr qnode
                              C 
00000000                      C qdesc	struct
00000000                      C head	ptr ?
00000008                      C tail	ptr ?
00000010                      C qdesc	ends
                              C qdesc_t typedef ptr qdesc
                              C 
                              C QEnqueue proto fastcall :ptr qdesc, :ptr
                              C QAddItem proto fastcall :ptr qdesc, :ptr
                              C 
                              C endif
                              C include namespace.inc
                              C ; NAMESPACE.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C 
                              C ifndef __NAMESPACE_INC
 = 0                          C define __NAMESPACE_INC
                              C 
                              C .template nsp_item
00000000                    * C nsp_item struct
00000000                      C     next ptr nsp_item ?
00000008                      C     name ptr sbyte ?
                              C    .ends
00000010                    * C nsp_item ends
                              C 
                              C NameSpaceDirective  proto fastcall :int_t, :token_t
                              C NameSpace           proto watcall :string_t, :string_t
                              C 
                              C endif
                              C 
 = FFFFFFFE                   C define EMPTY            (-2) ; function return values
 = FFFFFFFF                   C define ERROR            (-1)
 = 0                          C define NOT_ERROR        0
 = 1                          C define STRING_EXPANDED  1
                              C 
 = 0                          C define PASS_1           0
 = 1                          C define PASS_2           1
                              C 
 = 1                          C define OPT_CSTACK       0x01
 = 2                          C define OPT_WSTRING      0x02 ; convert "string" to unicode
 = 4                          C define OPT_LSTRING      0x04 ; L"Unicode" used --> allow dw "string"
 = 8                          C define OPT_PASCAL       0x08 ; auto insert break after cases
 = 10                         C define OPT_NOTABLE      0x10 ; no indexed jump table
 = 20                         C define OPT_REGAX        0x20 ; use [R|E]AX to render jump-code
 = 40                         C define OPT_ASSERT       0x40 ; Generate .assert code
 = 80                         C define OPT_PUSHF        0x80 ; Push/Pop flags
                              C 
                              C ; enumerations
                              C 
                              C ; output formats. Order must match formatoptions[] in assemble.asm
                              C 
                              C .enum oformat {
                            * C oformat typedef sdword
 = 0                        * C OFORMAT_BIN equ 0x0
 = 1                        * C OFORMAT_OMF equ 0x1
 = 2                        * C OFORMAT_COFF equ 0x2
 = 3                        * C OFORMAT_ELF equ 0x3
                              C 
                              C .enum sformat {
                            * C sformat typedef sdword
 = 0                        * C SFORMAT_NONE equ 0x0
 = 1                        * C SFORMAT_MZ equ 0x1
 = 2                        * C SFORMAT_PE equ 0x2
 = 3                        * C SFORMAT_64BIT equ 0x3
                              C 
                              C .enum fpo {
                            * C fpo typedef sdword
 = 0                        * C FPO_NO_EMULATION equ 0x0
 = 1                        * C FPO_EMULATION equ 0x1
                              C 
                              C ; language values.
                              C ; the order cannot be changed, it's
                              C ; returned by OPATTR and used in user-defined prologue/epilogue.
                              C 
                              C .enum lang_type {
                            * C lang_type typedef sdword
 = 0                        * C LANG_NONE equ 0x0
 = 1                        * C LANG_C equ 0x1
 = 2                        * C LANG_SYSCALL equ 0x2
 = 3                        * C LANG_STDCALL equ 0x3
 = 4                        * C LANG_PASCAL equ 0x4
 = 5                        * C LANG_FORTRAN equ 0x5
 = 6                        * C LANG_BASIC equ 0x6
 = 7                        * C LANG_FASTCALL equ 0x7
 = 8                        * C LANG_VECTORCALL equ 0x8
 = 9                        * C LANG_WATCALL equ 0x9
                              C 
                              C ; Memory model type.
                              C ; the order cannot be changed, it's
                              C ; the value of the predefined @Model symbol.
                              C 
                              C .enum model_type {
                            * C model_type typedef sdword
 = 0                        * C MODEL_NONE equ 0x0
 = 1                        * C MODEL_TINY equ 0x1
 = 2                        * C MODEL_SMALL equ 0x2
 = 3                        * C MODEL_COMPACT equ 0x3
 = 4                        * C MODEL_MEDIUM equ 0x4
 = 5                        * C MODEL_LARGE equ 0x5
 = 6                        * C MODEL_HUGE equ 0x6
 = 7                        * C MODEL_FLAT equ 0x7
                              C 
 = 68                         C define SIZE_DATAPTR 0x68 ; far for COMPACT, LARGE, HUGE
 = 70                         C define SIZE_CODEPTR 0x70 ; far for MEDIUM, LARGE, HUGE
                              C 
                              C .enum seg_order {
                            * C seg_order typedef sdword
 = 0                        * C SEGORDER_SEQ equ 0x0
 = 1                        * C SEGORDER_DOSSEG equ 0x1
 = 2                        * C SEGORDER_ALPHA equ 0x2
                              C 
                              C ; .NOLISTMACRO, .LISTMACRO and .LISTMACROALL directives setting
                              C 
                              C .enum listmacro {
                            * C listmacro typedef sdword
 = 0                        * C LM_NOLISTMACRO equ 0x0
 = 1                        * C LM_LISTMACRO equ 0x1
 = 2                        * C LM_LISTMACROALL equ 0x2
                              C 
                              C ; assume values are used as index in codegen.c / invoke.c.
                              C ; Order must match the one in special.h. Don't change!
                              C 
                              C .enum assume_segreg {
                            * C assume_segreg typedef sdword
 = FFFFFFFE                 * C ASSUME_NOTHING equ 0xFFFFFFFE
 = 0                        * C ASSUME_ES equ 0x0
 = 1                        * C ASSUME_CS equ 0x1
 = 2                        * C ASSUME_SS equ 0x2
 = 3                        * C ASSUME_DS equ 0x3
 = 4                        * C ASSUME_FS equ 0x4
 = 5                        * C ASSUME_GS equ 0x5
                              C 
                              C .enum cpu_info {
                            * C cpu_info typedef sdword
                              C 
                              C     ; bit count from left:
                              C 
                              C     ; bit 0-2:     Math coprocessor
                              C     ; bit 3:       privileged?
                              C     ; bit 4-7:     cpu type
                              C     ; bit 8-15;    extension set
                              C 
 = 1                        * C P_NO87 equ 0x1
 = 2                        * C P_87 equ 0x2
 = 3                        * C P_287 equ 0x3
 = 4                        * C P_387 equ 0x4
                              C 
 = 8                        * C P_PM equ 0x8
                              C 
 = 0                        * C P_86 equ 0x0
 = 10                       * C P_186 equ 0x10
 = 20                       * C P_286 equ 0x20
 = 30                       * C P_386 equ 0x30
 = 40                       * C P_486 equ 0x40
 = 50                       * C P_586 equ 0x50
 = 60                       * C P_686 equ 0x60
 = 70                       * C P_64 equ 0x70
                              C 
 = 28                       * C P_286p equ 0x28
 = 38                       * C P_386p equ 0x38
 = 48                       * C P_486p equ 0x48
 = 58                       * C P_586p equ 0x58
 = 68                       * C P_686p equ 0x68
 = 78                       * C P_64p equ 0x78
                              C 
 = 100                      * C P_MMX equ 0x100
 = 200                      * C P_K3D equ 0x200
 = 400                      * C P_SSE1 equ 0x400
 = 800                      * C P_SSE2 equ 0x800
 = 1000                     * C P_SSE3 equ 0x1000
 = 2000                     * C P_SSSE3 equ 0x2000
 = 4000                     * C P_SSE4 equ 0x4000
 = 8000                     * C P_AVX equ 0x8000
                              C 
                              C     ; all SSE extension instructions
                              C 
 = FC00                     * C P_SSEALL equ 0xFC00
 = FD00                     * C NO_OPPRFX equ 0xFD00
                              C 
 = 7                        * C P_FPU_MASK equ 0x7
 = F0                       * C P_CPU_MASK equ 0xF0
                              C 
 = FF00                     * C P_EXT_MASK equ 0xFF00
 = FF00                     * C P_EXT_ALL equ 0xFF00
                              C 
                              C 
                              C ; the MASM compatible @CPU value flags:
                              C 
                              C .enum masm_cpu {
                            * C masm_cpu typedef sdword
 = 1                        * C M_8086 equ 0x1
 = 2                        * C M_186 equ 0x2
 = 4                        * C M_286 equ 0x4
 = 8                        * C M_386 equ 0x8
 = 10                       * C M_486 equ 0x10
 = 20                       * C M_586 equ 0x20
 = 40                       * C M_686 equ 0x40
 = 7F                       * C M_CPUMSK equ 0x7F
 = 80                       * C M_PROT equ 0x80
 = 100                      * C M_8087 equ 0x100
 = 400                      * C M_287 equ 0x400
 = 800                      * C M_387 equ 0x800
                              C 
                              C .enum segofssize {
                            * C segofssize typedef sdword
 = FE                       * C USE_EMPTY equ 0xFE
 = 0                        * C USE16 equ 0x0
 = 1                        * C USE32 equ 0x1
 = 2                        * C USE64 equ 0x2
                              C 
                              C 
                              C ; fastcall types. if order is to be changed or entries
                              C ; added, also adjust tables in proc.c, mangle.c and probably invoke.c!
                              C 
 = 0                          C define FCT_MSC      0   ; MS 16-/32-bit fastcall (ax,dx,cx / ecx,edx)
 = 1                          C define FCT_WATCOMC  1   ; OW register calling convention (eax, ebx, ecx, edx)
 = 2                          C define FCT_WIN64    2   ; Win64 fastcall convention (rcx, rdx, r8, r9)
 = 3                          C define FCT_ELF64    3   ; Linux 64 syscall
 = 4                          C define FCT_VEC32    4
 = 5                          C define FCT_VEC64    5
                              C 
                              C .enum stdcall_decoration {
                            * C stdcall_decoration typedef sdword
 = 0                        * C STDCALL_FULL equ 0x0
 = 1                        * C STDCALL_NONE equ 0x1
 = 2                        * C STDCALL_HALF equ 0x2
                              C 
                              C ; file extensions. Order must match first entries in enum opt_names!
                              C 
                              C .enum file_extensions {
                            * C file_extensions typedef sdword
 = 0                        * C ASM equ 0x0
 = 1                        * C OBJ equ 0x1
 = 2                        * C LST equ 0x2
 = 3                        * C ERR equ 0x3
 = 4                        * C NUM_FILE_TYPES equ 0x4
                              C 
                              C ; first 4 entries must match enum file_extensions!
                              C 
                              C .enum opt_names {
                            * C opt_names typedef sdword
 = 0                        * C OPTN_ASM_FN equ 0x0
 = 1                        * C OPTN_OBJ_FN equ 0x1
 = 2                        * C OPTN_LST_FN equ 0x2
 = 3                        * C OPTN_ERR_FN equ 0x3
 = 4                        * C OPTN_LNKDEF_FN equ 0x4
 = 5                        * C OPTN_MODULE_NAME equ 0x5
 = 6                        * C OPTN_TEXT_SEG equ 0x6
 = 7                        * C OPTN_DATA_SEG equ 0x7
 = 8                        * C OPTN_CODE_CLASS equ 0x8
 = 9                        * C OPTN_LAST equ 0x9
                              C 
                              C ; queues to store multiple cmdline switch values
                              C 
                              C .enum opt_queues {
                            * C opt_queues typedef sdword
 = 0                        * C OPTQ_FINCLUDE equ 0x0
 = 1                        * C OPTQ_MACRO equ 0x1
 = 2                        * C OPTQ_INCPATH equ 0x2
 = 3                        * C OPTQ_LAST equ 0x3
                              C 
                              C .enum prologue_epilogue_mode {
                            * C prologue_epilogue_mode typedef sdword
 = 0                        * C PEM_DEFAULT equ 0x0
 = 1                        * C PEM_MACRO equ 0x1
 = 2                        * C PEM_NONE equ 0x2
                              C 
                              C ; Stack distance
                              C 
                              C .enum dist_type {
                            * C dist_type typedef sdword
 = 0                        * C STACK_NEAR equ 0x0
 = 1                        * C STACK_FAR equ 0x1
                              C 
                              C ; Type of operating system
                              C 
                              C .enum os_type {
                            * C os_type typedef sdword
 = 0                        * C OPSYS_DOS equ 0x0
 = 1                        * C OPSYS_OS2 equ 0x1
                              C 
                              C .enum offset_type {
                            * C offset_type typedef sdword
 = 0                        * C OT_GROUP equ 0x0
 = 1                        * C OT_FLAT equ 0x1
 = 2                        * C OT_SEGMENT equ 0x2
                              C 
                              C .enum line_output_flags {
                            * C line_output_flags typedef sdword
 = 1                        * C LOF_LISTED equ 0x1
 = 2                        * C LOF_SKIPPOS equ 0x2
                              C 
                              C 
                              C ; flags for win64_flags
                              C 
                              C .enum win64_flag_values {
                            * C win64_flag_values typedef sdword
 = 1                        * C W64F_SAVEREGPARAMS equ 0x1
 = 2                        * C W64F_AUTOSTACKSP equ 0x2
 = 4                        * C W64F_STACKALIGN16 equ 0x4
 = 7                        * C W64F_ALL equ 0x7
                              C 
                              C ; codeview debug info extend
                              C 
                              C .enum cvex_values {
                            * C cvex_values typedef sdword
 = 0                        * C CVEX_MIN equ 0x0
 = 1                        * C CVEX_REDUCED equ 0x1
 = 2                        * C CVEX_NORMAL equ 0x2
 = 3                        * C CVEX_MAX equ 0x3
                              C 
                              C ; codeview debug info option flags
                              C 
                              C .enum cvoption_flags {
                            * C cvoption_flags typedef sdword
 = 1                        * C CVO_STATICTLS equ 0x1
                              C 
                              C .enum seg_type {
                            * C seg_type typedef sdword
 = 0                        * C SEGTYPE_UNDEF equ 0x0
 = 1                        * C SEGTYPE_CODE equ 0x1
 = 2                        * C SEGTYPE_DATA equ 0x2
 = 3                        * C SEGTYPE_BSS equ 0x3
 = 4                        * C SEGTYPE_STACK equ 0x4
 = 5                        * C SEGTYPE_ABS equ 0x5
 = 6                        * C SEGTYPE_HDR equ 0x6
 = 7                        * C SEGTYPE_CDATA equ 0x7
 = 8                        * C SEGTYPE_RELOC equ 0x8
 = 9                        * C SEGTYPE_RSRC equ 0x9
 = A                        * C SEGTYPE_ERROR equ 0xA
                              C 
 = 1                          C define CSF_GRPCHK      1
                              C 
 = 0                          C define CSI_TEXT        0
 = 1                          C define CSI_DATA        1
 = 2                          C define CSI_CONST       2
 = 3                          C define CSI_BSS         3
                              C 
 = 0                          C define BLOCK_ACTIVE    0
 = 1                          C define BLOCK_INACTIVE  1
 = 2                          C define BLOCK_DONE      2
                              C 
 = 0                          C define SIT_FILE        0
 = 1                          C define SIT_MACRO       1
                              C 
                              C .template qditem
00000000                    * C qditem struct
00000000                      C     next            ptr qditem ?
00000008                      C     size            uint_t ?
                              C    .ends
00000010                    * C qditem ends
                              C 
                              C .template dll_desc
00000000                    * C dll_desc struct
00000000                      C     next            ptr dll_desc ?
00000008                      C     cnt             int_t ?
0000000C                      C     name            char_t ?
                              C    .ends
00000010                    * C dll_desc ends
                              C     dlldesc_t       typedef ptr dll_desc
                              C 
                              C .template qitem
00000000                    * C qitem struct
00000000                      C     next            ptr qitem ?
00000008                      C     value           db ?
                              C    .ends
00000010                    * C qitem ends
                              C 
                              C .template src_item
00000000                    * C src_item struct
00000000                      C     next            ptr src_item ?
00000008                      C     type            dw ?    ; item type ( see enum src_item_type )
0000000A                      C     srcfile         dw ?    ; index of file in ModuleInfo.FNames
0000000C                      C     union
00000000                      C      content        ptr_t ? ; generic
00000000                      C      file           ptr_t ? ; if item is a file
00000000                      C      mi             ptr_t ? ; if item is a macro
00000008                      C     ends
00000018                      C     line_num        uint_t ? ; current line #
                              C    .ends
00000020                    * C src_item ends
                              C     srcitem_t       typedef ptr src_item
                              C 
                              C 
                              C .template format_options
00000000                    * C format_options struct
                              C     init            proc local fastcall :ptr module_info
                            * C T$0005 typedef proto fastcall :ptr module_info
                            * C P$0005 typedef ptr T$0005
00000000                    * C init P$0005 ?
00000008                      C     invalid_fixup_type sword ?
0000000A                      C     formatname      char_t 6 dup(?)
                              C    .ends
00000010                    * C format_options ends
                              C 
                              C .template com_item
00000000                    * C com_item struct
00000000                      C     cmd         dd ?
00000008                      C     class       string_t ?
00000010                      C     langtype    dd ?
00000018                      C     publsym     ptr asym ?  ; .class name : public class
00000020                      C     method      dd ?        ; .INLINE/.OPERATOR/.STATIC
00000028                      C     sym         ptr asym ?  ; set by StructDirective()
                              C    .ends
00000030                    * C com_item ends
                              C 
                              C 
                              C .template global_options
00000000                    * C global_options struct
00000000                      C     quiet                   db ?    ; -q option
00000001                      C     line_numbers            db ?    ; -Zd option
00000002                      C     debug_symbols           db ?    ; -Zi option
00000003                      C     debug_ext               db ?    ; -Zi option numeric argument
00000004                      C     floating_point          dd ?    ; -FPi, -FPi87
00000008                      C     error_limit             dd ?    ; -e option
0000000C                      C     no_error_disp           db ?    ; -eq option
0000000D                      C     warning_level           db ?    ; -Wn option
0000000E                      C     warning_error           db ?    ; -WX option
0000000F                      C     process_subdir          db ?    ; -r option
00000010                      C     names                   string_t OPTN_LAST dup(?) ; char *  4
00000058                      C     queues                  ptr_t OPTQ_LAST dup(?)  ; qitem * 4
00000070                      C     no_comment_in_code_rec  db ?    ; -zlc option
00000071                      C     no_opt_farcall          db ?    ; -zld option
00000072                      C     no_file_entry           db ?    ; -zlf option
00000073                      C     no_static_procs         db ?    ; -zlp option
00000074                      C     no_section_aux_entry    db ?    ; -zls option
00000075                      C     no_cdecl_decoration     db ?    ; -zcw & -zcm option
00000076                      C     stdcall_decoration      db ?    ; -zt<0|1|2> option
00000077                      C     no_export_decoration    db ?    ; -zze option
00000078                      C     entry_decorated         db ?    ; -zzs option
00000079                      C     write_listing           db ?    ; -Fl option
0000007A                      C     write_impdef            db ?    ; -Fd option
0000007B                      C     case_sensitive          db ?    ; -C<p|x|u> options
0000007C                      C     convert_uppercase       db ?    ; -C<p|x|u> options
0000007D                      C     preprocessor_stdout     db ?    ; -EP option
0000007E                      C     masm51_compat           db ?    ; -Zm option
0000007F                      C     strict_masm_compat      db ?    ; -Zne option
00000080                      C     masm_compat_gencode     db ?    ; -Zg option
00000081                      C     masm8_proc_visibility   db ?    ; -Zv8 option
00000082                      C     listif                  db ?    ; -Sx, -Sa option
00000083                      C     list_generated_code     db ?    ; -Sg, -Sa option
00000084                      C     list_macro              dd ?    ; -Sa option
00000088                      C     no_symbol_listing       db ?    ; -Sn option
00000089                      C     first_pass_listing      db ?    ; -Sf option
0000008A                      C     all_symbols_public      db ?    ; -Zf option
0000008B                      C     safeseh                 db ?    ; -safeseh option
0000008C                      C     output_format           dd ?    ; -bin, -omf, -coff, -elf options
00000090                      C     sub_format              dd ?    ; -mz, -pe, -win64, -elf64 options
00000094                      C     langtype                dd ?    ; -Gc|d|z option
00000098                      C     _model                  dd ?    ; -mt|s|m|c|l|h|f option
0000009C                      C     cpu                     dd ?    ; -0|1|2|3|4|5|6 & -fp{0|2|3|5|6|c} option
000000A0                      C     fctype                  dd ?    ; -zf0 & -zf1 option
000000A4                      C     codepage                dd ?    ; Unicode code page
000000A8                      C     ignore_include          db ?    ; -X option
000000A9                      C     fieldalign              db ?    ; -Zp option
000000AA                      C     syntax_check_only       db ?    ; -Zs option
000000AB                      C     xflag                   db ?    ; extended option
000000AC                      C     loopalign               db ?    ; OPTION:LOOPALIGN setting
000000AD                      C     casealign               db ?    ; OPTION:CASEALIGN setting
000000AE                      C     epilogueflags           db ?    ; OPTION EPILOGUE: FLAGS
000000AF                      C     segmentalign            db ?    ; -Sp[n] Set segment alignment
000000B0                      C     pe_subsystem            db ?    ; -cui, -gui
000000B1                      C     win64_flags             db ?    ; -homeparams, -autostack, -stackalign
000000B2                      C     chkstack                db ?    ; _chkstk()
000000B3                      C     nolib                   db ?    ; skip includelib directives
000000B4                      C     masm_keywords           db ?    ; -Znk
000000B5                      C     arch                    db ?    ; -arch:AVX[2|512]
000000B6                      C     frame_auto              db ?    ; -frame
000000B7                      C     floatformat             db ?    ; option floatformat:<e|f|g>
000000B8                      C     floatdigits             dd ?    ; option floatdigits:<value>
000000BC                      C     flt_size                db ?    ; option float:<4|8>
                              C    .ends
000000C0                    * C global_options ends
                              C 
                              C .template module_vars
00000000                    * C module_vars struct
00000000                      C     error_count             uint_t ?        ; total of errors so far
00000004                      C     warning_count           uint_t ?        ; total of warnings so far
00000008                      C     num_segs                uint_t ?        ; number of segments in module
00000010                      C     PubQueue                qdesc <>        ; PUBLIC items
00000020                      C     LnameQueue              qdesc <>        ; LNAME items (segments, groups and classes)
00000030                      C     SafeSEHQueue            qdesc <>        ; list of safeseh handlers
00000040                      C     LibQueue                qdesc <>        ; includelibs
00000050                      C     LinkQueue               qdesc <>        ; .pragma comment(linker,"/..")
00000060                      C     DllQueue                ptr dll_desc ?  ; dlls of OPTION DLLIMPORT
00000068                      C     imp_prefix              string_t ?              ;
00000070                      C     curr_file               LPFILE NUM_FILE_TYPES dup(?) ; ASM, ERR, OBJ and LST
00000090                      C     curr_fname              string_t NUM_FILE_TYPES dup(?)
000000B0                      C     FNames                  array_t ?       ; array of input files
000000B8                      C     cnt_fnames              uint_t ?        ; items in FNames array
000000C0                      C     IncludePath             string_t ?              ;
000000C8                      C     line_queue              qdesc <>        ; line queue
000000D8                      C     src_stack               ptr src_item ?  ; source item (files & macros) stack
000000E0                      C     union
00000000                      C      start_fixup            ptr fixup ?     ; OMF only
00000000                      C      start_label            ptr asym ?      ; non-OMF only: start label
00000008                      C     ends
000000E8                      C     start_displ             uint_t ?        ; OMF only, optional displ for start label
000000F0                      C     StrStack                ptr str_item ?  ; v2.20 String stack
000000F8                      C     HllStack                ptr hll_item ?  ; for .WHILE, .IF, .REPEAT
00000100                      C     HllFree                 ptr hll_item ?  ; v2.06: stack of free <struct hll>-items
00000108                      C     ComStack                ptr com_item ?  ; v2.27: .CLASSDEF, .COMDEF, .ENDS
00000110                      C     RetStack                ptr hll_item ?  ; v2.30: .return info
00000118                      C     FltStack                ptr flt_item ?  ; v2.31 float stack
00000120                      C     NspStack                ptr nsp_item ?  ; v2.33 namespace stack
00000128                      C     ContextStack            ptr byte ?
00000130                      C     ContextFree             ptr byte ?      ; v2.10: "free items" heap implemented.
00000138                      C     SavedContexts           ptr byte ?
00000140                      C     cntSavedContexts        int_t ?
00000144                      C     anonymous_label         uint_t ?        ; "anonymous label" counter
00000148                      C     StackBase               ptr asym ?
00000150                      C     ProcStatus              ptr asym ?
                              C     WriteModule             proc local fastcall :ptr module_info
                            * C T$0006 typedef proto fastcall :ptr module_info
                            * C P$0006 typedef ptr T$0006
00000158                    * C WriteModule P$0006 ?
                              C     EndDirHook              proc local fastcall :ptr module_info
                            * C T$0007 typedef proto fastcall :ptr module_info
                            * C P$0007 typedef ptr T$0007
00000160                    * C EndDirHook P$0007 ?
                              C     Pass1Checks             proc local fastcall :ptr module_info
                            * C T$0008 typedef proto fastcall :ptr module_info
                            * C P$0008 typedef ptr T$0008
00000168                    * C Pass1Checks P$0008 ?
00000170                      C     pe_flags                uint_t ?
00000174                      C     max_line_len            uint_t ?
                              C    .ends
00000178                    * C module_vars ends
                              C 
                              C .template module_info : public module_vars
00000000                    * C module_info struct
00000000                    * C module_vars <>
00000178                      C     proc_prologue           string_t ?      ; prologue macro if PEM_MACRO
00000180                      C     proc_epilogue           string_t ?      ; epilogue macro if PEM_MACRO
00000188                      C     CurrDll                 ptr dll_desc ?  ; OPTION DLLIMPORT dll
00000190                      C     fmtopt                  ptr format_options ? ; v2.07: added
00000198                      C     hll_label               dd ?    ; hll directive label counter
0000019C                      C     distance                db ?    ; stack distance
0000019D                      C     _model                  db ?    ; memory model
0000019E                      C     langtype                db ?    ; language
0000019F                      C     ostype                  db ?    ; operating system
000001A0                      C     sub_format              db ?    ; sub-output format
000001A1                      C     fctype                  db ?    ; fastcall type
000001A2                      C     segorder                db ?    ; .alpha, .seq, .dosseg
000001A3                      C     offsettype              db ?    ; OFFSET:GROUP|FLAT|SEGMENT
000001A4                      C     cpu                     dd ?    ; cpu setting (value @cpu symbol);
000001A8                      C     curr_cpu                dd ?    ; cpu setting (OW stylex);
000001AC                      C     radix                   db ?    ; current .RADIX setting
000001AD                      C     fieldalign              db ?    ; -Zp, OPTION:FIELDALIGN setting
000001AE                      C     line_flags              db ?    ; current line has been printed
000001AF                      C     procalign               db ?    ; current OPTION:PROCALIGN setting
000001B0                      C     list_macro              dd ?    ; current .LISTMACRO setting
000001B4                      C     Ofssize                 db ?    ; current offset size (USE16,USE32,USE64)
000001B5                      C     defOfssize              db ?    ; default segment offset size (16,32 [,64]-bit)
000001B6                      C     wordsize                db ?    ; current word size (2,4,8)
000001B7                      C     inside_comment          db ?    ; v2.10: moved from tokenize.c
000001B8                      C     case_sensitive          db ?    ; option casemap
000001B9                      C     convert_uppercase       db ?    ; option casemap
000001BA                      C     procs_private           db ?    ; option proc:private
000001BB                      C     procs_export            db ?    ; option proc:export
000001BC                      C     dotname                 db ?    ; option dotname
000001BD                      C     ljmp                    db ?    ; option ljmp
000001BE                      C     m510                    db ?    ; option m510
000001BF                      C     scoped                  db ?    ; option scoped
000001C0                      C     oldstructs              db ?    ; option oldstructs
000001C1                      C     emulator                db ?    ; option emulator
000001C2                      C     setif2                  db ?    ; option setif2
000001C3                      C     list                    db ?    ; .list/.nolist
000001C4                      C     cref                    db ?    ; .cref/.nocref
000001C5                      C     listif                  db ?    ; .listif/.nolistif
000001C6                      C     list_generated_code     db ?    ; .listall, -Sa, -Sg
000001C7                      C     StartupDirectiveFound   db ?
000001C8                      C     EndDirFound             db ?
000001C9                      C     frame_auto              db ?    ; win64 only
000001CA                      C     NoSignExtend            db ?    ; option nosignextend
000001CB                      C     simseg_init             db ?    ; simplified segm dir flags
000001CC                      C     union
00000000                      C      struct
00000000                      C       elf_osabi             db ?    ; for ELF
00000001                      C       win64_flags           db ?    ; for WIN64 + PE(32+)
00000002                      C      ends
00000002                      C      struct
00000000                      C       mz_ofs_fixups         dw ?    ; for MZ
00000002                      C       mz_alignment          dw ?
00000004                      C       mz_heapmin            dw ?
00000006                      C       mz_heapmax            dw ?
00000008                      C      ends
00000008                      C     ends
000001D4                      C     simseg_defd             db ?            ; v2.09: flag if seg was defined before simseg dir
000001D5                      C     PhaseError              db ?            ; phase error flag
000001D6                      C     CommentDataInCode       db ?            ; OMF: emit coment records about data in code segs
000001D7                      C     prologuemode            db ?            ; current PEM_ enum value for OPTION PROLOGUE
000001D8                      C     epiloguemode            db ?            ; current PEM_ enum value for OPTION EPILOGUE
000001D9                      C     invoke_exprparm         db ?            ; flag: forward refs for INVOKE params ok?
000001DA                      C     cv_opt                  db ?            ; option codeview
000001DB                      C     strict_masm_compat      db ?            ; -Zne option
000001DC                      C     srcfile                 uint_t ?        ; main source file - is an index for FNames[]
000001E0                      C     currseg                 ptr dsym ?      ; currently active segment - dsym *
000001E8                      C     flat_grp                ptr dsym ?      ; magic FLAT group - dsym *
000001F0                      C     pCodeBuff               ptr byte ?
000001F8                      C     GeneratedCode           uint_t ?        ; nesting level generated code
00000200                      C     currsource              string_t ?      ; current source line
00000208                      C     CurrComment             string_t ?      ; current comment
00000210                      C     tokenarray              ptr asm_tok ?   ; start token buffer
00000218                      C     stringbufferend         string_t ?      ; start free space in string buffer
00000220                      C     token_count             int_t ?         ; number of tokens in curr line
00000224                      C     basereg                 uint_t 3 dup(?) ; stack base register (16-, 32-, 64-bit
00000230                      C     name                    db 260 dup(?)   ; name of module
00000334                      C     xflag                   db ?            ; extended option
00000335                      C     loopalign               db ?            ; OPTION:LOOPALIGN setting
00000336                      C     casealign               db ?            ; OPTION:CASEALIGN setting
00000337                      C     epilogueflags           db ?            ; OPTION EPILOGUE: FLAGS
00000338                      C     assert_proc             string_t ?      ; .assert:<proc/macro name>
00000340                      C     codepage                uint_t ?
00000344                      C     class_label             uint_t ?
00000348                      C     floatformat             db ?            ; option floatformat:<e|f|g>
00000349                      C     flt_size                db ?            ; option float:<4|8>
0000034C                      C     floatdigits             int_t ?         ; option floatdigits:<value>
                              C    .ends
00000350                    * C module_info ends
                              C 
 = ModuleInfo.token_count     C Token_Count             equ <ModuleInfo.token_count>
 = ModuleInfo.currsource      C CurrSource              equ <ModuleInfo.currsource>
 = ModuleInfo.wordsize        C CurrWordSize            equ <ModuleInfo.wordsize>
 = ModuleInfo.curr_file       C CurrFile                equ <ModuleInfo.curr_file>
 = ModuleInfo.currseg         C CurrSeg                 equ <ModuleInfo.currseg>
 = ModuleInfo.curr_fname      C CurrFName               equ <ModuleInfo.curr_fname>
 = ModuleInfo.stringbufferen  C StringBufferEnd         equ <ModuleInfo.stringbufferend>
   d                            
                              C 
                              C externdef               Parse_Pass      : uint_t
                              C externdef               ModuleInfo      : module_info
                              C externdef               Options         : global_options
                              C externdef               write_to_file   : uint_t
                              C externdef               DefaultDir      : string_t      ; * NUM_FILE_TYPES
                              C externdef               MacroLevel      : uint_t
                              C externdef               LinnumQueue     : qdesc
                              C externdef               ModelToken      : string_t
                              C externdef               LastCodeBufSize : int_t
                              C externdef               stackreg        : uint_t
                              C externdef               regax           : uint_t
                              C externdef               szDgroup        : char_t        ; DGROUP
                              C 
                              C 
                              C AssembleModule          proto fastcall :string_t
                              C close_files             proto fastcall
                              C CmdlineFini             proto fastcall
                              C ParseCmdline            proto fastcall :ptr string_t, :ptr int_t
                              C write_usage             proto fastcall
                              C define_name             proto fastcall :string_t, :string_t
                              C 
                              C asmerr                  proto fastcall :int_t, :vararg
                              C DelayExpand             proto fastcall :token_t
                              C AsmcKeywords            proto fastcall :int_t
                              C 
                              C write_logo              proto fastcall
                              C SetCPU                  proto fastcall :int_t
                              C OutputByte              proto fastcall :int_t
                              C FillDataBytes           proto fastcall :byte, :int_t
                              C OutputBytes             proto fastcall :ptr byte, :int_t, :ptr fixup
                              C AddLinnumDataRef        proto fastcall :uint_t, :uint_t
                              C myltoa                  proto fastcall :qword, :string_t, :uint_t, :int_t, :int_t
                              C write_options           proto fastcall
                              C ConvertSectionName      proto fastcall :ptr asym, :ptr dword, :string_t
                              C SetMasm510              proto fastcall :int_t
                              C GetType                 proto fastcall :string_t, :ptr expr, :string_t, :int_t
                              C RetLineQueue            proto fastcall
                              C 
                              C 
                              C tprintf                 proto fastcall :string_t, :vararg
                              C tsprintf                proto fastcall :string_t, :string_t, :vararg
                              C tvsprintf               proto fastcall :string_t, :string_t, :ptr
                              C tvfprintf               proto fastcall :ptr FILE, :string_t, :ptr
                              C tstrupr                 proto fastcall :string_t
                              C 
                              C tmemcpy                 proto fastcall :ptr, :ptr, :uint_t
                              C tmemmove                proto fastcall :ptr, :ptr, :uint_t
                              C tmemcmp                 proto fastcall :ptr, :ptr, :uint_t
                              C tmemicmp                proto fastcall :ptr, :ptr, :uint_t
                              C tmemset                 proto fastcall :ptr, :int_t, :uint_t
                              C tstrlen                 proto fastcall :string_t
                              C tstrchr                 proto fastcall :string_t, :int_t
                              C tstrrchr                proto fastcall :string_t, :int_t
                              C tstrcpy                 proto fastcall :string_t, :string_t
                              C tstrcat                 proto fastcall :string_t, :string_t
                              C tstrncpy                proto fastcall :string_t, :string_t, :int_t
                              C tstrcmp                 proto fastcall :string_t, :string_t
                              C tstricmp                proto fastcall :string_t, :string_t
                              C tstrstr                 proto fastcall :string_t, :string_t
                              C tgetenv                 proto fastcall :string_t
                              C 
                              C tstrstart               proto watcall :string_t
                              C tstrstartr              proto watcall :string_t
                              C 
                             1C     ?PQSORTCMD typedef proto fastcall :ptr,:ptr
                              C PQSORTCMD typedef ptr ?PQSORTCMD
                              C 
                              C tqsort                  proto fastcall :ptr, :int_t, :int_t, :PQSORTCMD
                              C 
                              C endif

                                    public  _ltype

                                    .data
00000000                    *   _DATA segment
                            *   assume cs:ERROR

                                _ltype byte 0,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_SPACE+_CONTROL,_SPACE+_CONTROL,_SPACE+_CONTROL,_SPACE+_CONTROL,_SPACE+_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_CONTROL,_SPACE,_PUNCT,_PUNCT,_PUNCT,_PUNCT+_LABEL,_PUNCT,_PUNCT,_PUNCT,_PUNCT,_PUNCT,_PUNCT,_PUNCT,_PUNCT,_PUNCT,_PUNCT,_PUNCT,_DIGIT+_HEX,_DIGIT+_HEX,_DIGIT+_HEX,_DIGIT+_HEX,_DIGIT+_HEX,_DIGIT+_HEX,_DIGIT+_HEX,_DIGIT+_HEX,_DIGIT+_HEX,_DIGIT+_HEX,_PUNCT,_PUNCT,_PUNCT,_PUNCT,_PUNCT,_PUNCT+_LABEL,_PUNCT+_LABEL,_UPPER+_LABEL+_HEX,_UPPER+_LABEL+_HEX,_UPPER+_LABEL+_HEX,_UPPER+_LABEL+_HEX,_UPPER+_LABEL+_HEX,_UPPER+_LABEL+_HEX,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_UPPER+_LABEL,_PUNCT,_PUNCT,_PUNCT,_PUNCT,_PUNCT+_LABEL,_PUNCT,_LOWER+_LABEL+_HEX,_LOWER+_LABEL+_HEX,_LOWER+_LABEL+_HEX,_LOWER+_LABEL+_HEX,_LOWER+_LABEL+_HEX,_LOWER+_LABEL+_HEX,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_LOWER+_LABEL,_PUNCT,_PUNCT,_PUNCT,_PUNCT,_CONTROL            ; 7F (DEL)

                                    db 128 dup(0)       ; and the rest are 0...

00000000                            .code
                            *   _DATA ends
00000000                    *   _TEXT segment
                            *   assume cs:FLAT

                                    option dotname
                                    option win64:rsp noauto nosave

00000000                        tstrupr proc fastcall string:string_t

00000000                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
00000004                            push     rcx
00000005                        .0:
00000005                            mov     al,[rcx]
00000007                            test    al,al
00000009                            jz      .1

0000000B                            sub     al,'a'
0000000D                            cmp     al,'Z'-'A'+1
0000000F                            sbb     al,al
00000011                            and     al,'a'-'A'
00000013                            xor     [rcx],al
00000015                            inc     rcx
00000018                            jmp     .0
0000001A                        .1:
0000001A                            pop     rax
0000001B                            ret
0000001B                    *   add rsp, 8
0000001F                    *   retn 

00000000                    *   .xdata segment align(8) flat read 'DATA'
00000000                    *   $xdatasym label near
                            *   db 1t + (00h shl 3), 4t, 1t, 00h + (00h shl 4)
                            *   dw 0204h
                            *   ALIGN 4
                            *   .xdata ENDS
00000000                    *   .pdata SEGMENT ALIGN(4) flat read 'DATA'
                            *   dd IMAGEREL tstrupr, IMAGEREL tstrupr+020h, IMAGEREL $xdatasym+00h
                            *   .pdata ENDS
00000020                        tstrupr endp

00000020                        tstrstart proc watcall string:string_t

00000020                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
00000024                            movzx   ecx,byte ptr [rax]
00000027                            lea     rdx,_ltype
0000002E                        .0:
0000002E                            test    byte ptr [rdx+rcx+1],_SPACE
00000033                            jz      .1
00000035                            inc     rax
00000038                            mov     cl,[rax]
0000003A                            jmp     .0
0000003C                        .1:
0000003C                            ret
0000003C                    *   add rsp, 8
00000040                    *   retn 

00000008                    *   .xdata segment
                            *   db 1t + (00h shl 3), 4t, 1t, 00h + (00h shl 4)
                            *   dw 0204h
                            *   ALIGN 4
                            *   .xdata ENDS
0000000C                    *   .pdata SEGMENT
                            *   dd IMAGEREL tstrstart, IMAGEREL tstrstart+021h, IMAGEREL $xdatasym+08h
                            *   .pdata ENDS
00000041                        tstrstart endp

00000041                        tstrstartr proc watcall string:string_t

00000041                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
00000045                            movzx   ecx,byte ptr [rax]
00000048                            lea     rdx,_ltype
0000004F                        .0:
0000004F                            test    byte ptr[rdx+rcx+1],_SPACE
00000054                            jz      .1
00000056                            dec     rax
00000059                            mov     cl,[rax]
0000005B                            jmp     .0
0000005D                        .1:
0000005D                            ret
0000005D                    *   add rsp, 8
00000061                    *   retn 

00000010                    *   .xdata segment
                            *   db 1t + (00h shl 3), 4t, 1t, 00h + (00h shl 4)
                            *   dw 0204h
                            *   ALIGN 4
                            *   .xdata ENDS
00000018                    *   .pdata SEGMENT
                            *   dd IMAGEREL tstrstartr, IMAGEREL tstrstartr+021h, IMAGEREL $xdatasym+010h
                            *   .pdata ENDS
00000062                        tstrstartr endp

                                ifndef __UNIX__
00000062                        memcpy::
                           D:\Asmc\source\asmc\x64\ltype.asm(202) : error A2005: symbol redefinition : memcpy
                                endif
00000062                        tmemcpy proc fastcall uses rdi dst:ptr, src:ptr, z:uint_t

00000062                    *    push rdi
                            *    .pushreg rdi
                            *   .endprolog
00000063                            mov     rax,rcx ; -- return value
00000066                            xchg    rsi,rdx
00000069                            mov     ecx,r8d
0000006C                            mov     rdi,rax
0000006F                            rep     movsb
00000071                            mov     rsi,rdx
00000074                            ret
00000074                    *   pop rdi
00000075                    *   retn 

00000018                    *   .xdata segment
                            *   db 1t + (00h shl 3), 1t, 1t, 00h + (00h shl 4)
                            *   dw 07001h
                            *   ALIGN 4
                            *   .xdata ENDS
00000024                    *   .pdata SEGMENT
                            *   dd IMAGEREL tmemcpy, IMAGEREL tmemcpy+014h, IMAGEREL $xdatasym+018h
                            *   .pdata ENDS
00000076                        tmemcpy endp

00000076                        tmemmove proc fastcall uses rsi rdi dst:ptr, src:ptr, z:uint_t

00000076                    *    push rsi
                            *    .pushreg rsi
00000077                    *    push rdi
                            *    .pushreg rdi
00000078                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
0000007C                            mov     rax,rcx ; -- return value
0000007F                            mov     rsi,rdx
00000082                            mov     ecx,r8d
00000085                            mov     rdi,rax
00000088                            cmp     rax,rsi
0000008B                            ja      .0
0000008D                            rep     movsb
0000008F                            jmp     .1
00000091                        .0:
00000091                            lea     rsi,[rsi+rcx-1]
00000096                            lea     rdi,[rdi+rcx-1]
0000009B                            std
0000009C                            rep     movsb
0000009E                            cld
0000009F                        .1:
0000009F                            ret
0000009F                    *   add rsp, 8
000000A3                    *   pop rdi
000000A4                    *   pop rsi
000000A5                    *   retn 

00000020                    *   .xdata segment
                            *   db 1t + (00h shl 3), 6t, 3t, 00h + (00h shl 4)
                            *   dw 0206h, 07002h, 06001h
                            *   ALIGN 4
                            *   .xdata ENDS
00000030                    *   .pdata SEGMENT
                            *   dd IMAGEREL tmemmove, IMAGEREL tmemmove+030h, IMAGEREL $xdatasym+020h
                            *   .pdata ENDS
000000A6                        tmemmove endp

000000A6                        tmemset proc fastcall uses rdi dst:ptr, char:int_t, count:uint_t

000000A6                    *    push rdi
                            *    .pushreg rdi
                            *   .endprolog
000000A7                            mov     rdi,rcx
000000AA                            mov     al,dl
000000AC                            mov     ecx,r8d
000000AF                            mov     r8,rdi
000000B2                            rep     stosb
000000B4                            mov     rax,r8
000000B7                            ret
000000B7                    *   pop rdi
000000B8                    *   retn 

0000002C                    *   .xdata segment
                            *   db 1t + (00h shl 3), 1t, 1t, 00h + (00h shl 4)
                            *   dw 07001h
                            *   ALIGN 4
                            *   .xdata ENDS
0000003C                    *   .pdata SEGMENT
                            *   dd IMAGEREL tmemset, IMAGEREL tmemset+013h, IMAGEREL $xdatasym+02Ch
                            *   .pdata ENDS
000000B9                        tmemset endp

                                ifndef __UNIX__
000000B9                        strlen::
                           D:\Asmc\source\asmc\x64\ltype.asm(250) : error A2005: symbol redefinition : strlen
                                endif
000000B9                        tstrlen proc fastcall uses rdi string:string_t

000000B9                    *    push rdi
                            *    .pushreg rdi
                            *   .endprolog
000000BA                            mov     rdi,rcx
000000BD                            mov     ecx,-1
000000C2                            xor     eax,eax
000000C4                            repnz   scasb
000000C6                            not     ecx
000000C8                            dec     ecx
000000CA                            mov     eax,ecx
000000CC                            ret
000000CC                    *   pop rdi
000000CD                    *   retn 

00000034                    *   .xdata segment
                            *   db 1t + (00h shl 3), 1t, 1t, 00h + (00h shl 4)
                            *   dw 07001h
                            *   ALIGN 4
                            *   .xdata ENDS
00000048                    *   .pdata SEGMENT
                            *   dd IMAGEREL tstrlen, IMAGEREL tstrlen+015h, IMAGEREL $xdatasym+034h
                            *   .pdata ENDS
000000CE                        tstrlen endp

                                ifndef __UNIX__
000000CE                        strchr::
                           D:\Asmc\source\asmc\x64\ltype.asm(266) : error A2005: symbol redefinition : strchr
                                endif
000000CE                        tstrchr proc fastcall string:string_t, char:int_t

000000CE                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
000000D2                            xor     eax,eax
000000D4                        .0:
000000D4                            mov     dh,[rcx]
000000D6                            test    dh,dh
000000D8                            jz      .1
000000DA                            cmp     dh,dl
000000DC                            cmovz   rax,rcx
000000E0                            lea     rcx,[rcx+1]
000000E4                            jnz     .0
000000E6                        .1:
000000E6                            ret
000000E6                    *   add rsp, 8
000000EA                    *   retn 

0000003C                    *   .xdata segment
                            *   db 1t + (00h shl 3), 4t, 1t, 00h + (00h shl 4)
                            *   dw 0204h
                            *   ALIGN 4
                            *   .xdata ENDS
00000054                    *   .pdata SEGMENT
                            *   dd IMAGEREL tstrchr, IMAGEREL tstrchr+01Dh, IMAGEREL $xdatasym+03Ch
                            *   .pdata ENDS
000000EB                        tstrchr endp

                                ifndef __UNIX__
000000EB                        strrchr::
                           D:\Asmc\source\asmc\x64\ltype.asm(285) : error A2005: symbol redefinition : strrchr
                                endif
000000EB                        tstrrchr proc fastcall string:string_t, char:int_t

000000EB                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
000000EF                            xor     eax,eax
000000F1                        .0:
000000F1                            mov     dh,[rcx]
000000F3                            test    dh,dh
000000F5                            jz      .1
000000F7                            cmp     dh,dl
000000F9                            cmovz   rax,rcx
000000FD                            add     rcx,1
00000101                            jmp     .0
00000103                        .1:
00000103                            ret
00000103                    *   add rsp, 8
00000107                    *   retn 

00000044                    *   .xdata segment
                            *   db 1t + (00h shl 3), 4t, 1t, 00h + (00h shl 4)
                            *   dw 0204h
                            *   ALIGN 4
                            *   .xdata ENDS
00000060                    *   .pdata SEGMENT
                            *   dd IMAGEREL tstrrchr, IMAGEREL tstrrchr+01Dh, IMAGEREL $xdatasym+044h
                            *   .pdata ENDS
00000108                        tstrrchr endp

                                ifndef __UNIX__
00000108                        strcpy::
                           D:\Asmc\source\asmc\x64\ltype.asm(304) : error A2005: symbol redefinition : strcpy
                                endif
00000108                        tstrcpy proc fastcall dst:string_t, src:string_t

00000108                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
0000010C                            mov     r9,rcx
0000010F                            mov     al,[rdx]
00000111                            mov     [rcx],al
00000113                            test    al,al
00000115                            jz      .2

00000117                            mov     al,[rdx+1]
0000011A                            mov     [rcx+1],al
0000011D                            test    al,al
0000011F                            jz      .2

00000121                            mov     al,[rdx+2]
00000124                            mov     [rcx+2],al
00000127                            test    al,al
00000129                            jz      .2

0000012B                            mov     al,[rdx+3]
0000012E                            mov     [rcx+3],al
00000131                            test    al,al
00000133                            jz      .2

00000135                            mov     al,[rdx+4]
00000138                            mov     [rcx+4],al
0000013B                            test    al,al
0000013D                            jz      .2

0000013F                            mov     al,[rdx+5]
00000142                            mov     [rcx+5],al
00000145                            test    al,al
00000147                            jz      .2

00000149                            mov     al,[rdx+6]
0000014C                            mov     [rcx+6],al
0000014F                            test    al,al
00000151                            jz      .2

00000153                            mov     al,[rdx+7]
00000156                            mov     [rcx+7],al
00000159                            test    al,al
0000015B                            jz      .2

0000015D                            add     rdx,8
00000161                            add     rcx,8
00000165                            mov     r10,0x8080808080808080
0000016F                            mov     r11,0x0101010101010101
00000179                        .0:
00000179                            mov     rax,[rdx]
0000017C                            mov     r8,rax
0000017F                            sub     r8,r11
00000182                            not     rax
00000185                            and     r8,rax
00000188                            not     rax
0000018B                            and     r8,r10
0000018E                            jnz     .1
00000190                            mov     [rcx],rax
00000193                            add     rcx,8
00000197                            add     rdx,8
0000019B                            jmp     .0
0000019D                        .1:
0000019D                            mov     [rcx],al
0000019F                            test    al,al
000001A1                            jz      .2

000001A3                            mov     [rcx+1],ah
000001A6                            test    ah,ah
000001A8                            jz      .2

000001AA                            shr     rax,16
000001AE                            mov     [rcx+2],al
000001B1                            test    al,al
000001B3                            jz      .2

000001B5                            mov     [rcx+3],ah
000001B8                            test    ah,ah
000001BA                            jz      .2

000001BC                            shr     rax,16
000001C0                            add     rcx,4
000001C4                            jmp     .1
000001DA                        .2:
000001DA                            mov     rax,r9
000001DD                            ret
000001DD                    *   add rsp, 8
000001E1                    *   retn 

0000004C                    *   .xdata segment
                            *   db 1t + (00h shl 3), 4t, 1t, 00h + (00h shl 4)
                            *   dw 0204h
                            *   ALIGN 4
                            *   .xdata ENDS
0000006C                    *   .pdata SEGMENT
                            *   dd IMAGEREL tstrcpy, IMAGEREL tstrcpy+0DAh, IMAGEREL $xdatasym+04Ch
                            *   .pdata ENDS
000001E2                        tstrcpy endp

000001E2                        tstrncpy proc fastcall dst:string_t, src:string_t, count:int_t

000001E2                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
000001E6                            mov     r10,rdi
000001E9                            mov     rdi,rcx
000001EC                            mov     r11,rcx
000001EF                            mov     ecx,r8d
000001F2                        .0:
000001F2                            test    ecx,ecx
000001F4                            jz      .2
000001F6                            dec     ecx
000001F8                            mov     al,[rdx]
000001FA                            mov     [rdi],al
000001FC                            add     rdx,1
00000200                            add     rdi,1
00000204                            test    al,al
00000206                            jnz     .0
00000208                        .1:
00000208                            rep     stosb
0000020A                        .2:
0000020A                            mov     rdi,r10
0000020D                            mov     rax,r11
00000210                            ret
00000210                    *   add rsp, 8
00000214                    *   retn 

00000054                    *   .xdata segment
                            *   db 1t + (00h shl 3), 4t, 1t, 00h + (00h shl 4)
                            *   dw 0204h
                            *   ALIGN 4
                            *   .xdata ENDS
00000078                    *   .pdata SEGMENT
                            *   dd IMAGEREL tstrncpy, IMAGEREL tstrncpy+033h, IMAGEREL $xdatasym+054h
                            *   .pdata ENDS
00000215                        tstrncpy endp

00000215                        tstrcat proc fastcall dst:string_t, src:string_t

00000215                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
00000219                            mov     r8,rcx
0000021C                            xor     eax,eax
0000021E                        .0:
0000021E                            cmp     al,[rcx]
00000220                            je      .1
00000222                            add     rcx,1
00000226                            jmp     .0
00000228                        .1:
00000228                            cmp     ah,[rdx]
0000022A                            je      .2
0000022C                            mov     al,[rdx]
0000022E                            mov     [rcx],al
00000230                            add     rdx,1
00000234                            add     rcx,1
00000238                            jmp     .1
0000023A                        .2:
0000023A                            mov     [rcx],ah
0000023C                            mov     rax,r8
0000023F                            ret
0000023F                    *   add rsp, 8
00000243                    *   retn 

0000005C                    *   .xdata segment
                            *   db 1t + (00h shl 3), 4t, 1t, 00h + (00h shl 4)
                            *   dw 0204h
                            *   ALIGN 4
                            *   .xdata ENDS
00000084                    *   .pdata SEGMENT
                            *   dd IMAGEREL tstrcat, IMAGEREL tstrcat+02Fh, IMAGEREL $xdatasym+05Ch
                            *   .pdata ENDS
00000244                        tstrcat endp

00000244                        tstrcmp proc fastcall a:string_t, b:string_t

00000244                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
00000248                            mov     eax,1
0000024D                        .0:
0000024D                            test    al,al
0000024F                            jz      .1
00000251                            mov     al,[rcx]
00000253                            inc     rdx
00000256                            inc     rcx
00000259                            cmp     al,[rdx-1]
0000025C                            je      .0
0000025E                            sbb     eax,eax
00000260                            sbb     eax,-1
00000263                        .1:
00000263                            ret
00000263                    *   add rsp, 8
00000267                    *   retn 

00000064                    *   .xdata segment
                            *   db 1t + (00h shl 3), 4t, 1t, 00h + (00h shl 4)
                            *   dw 0204h
                            *   ALIGN 4
                            *   .xdata ENDS
00000090                    *   .pdata SEGMENT
                            *   dd IMAGEREL tstrcmp, IMAGEREL tstrcmp+024h, IMAGEREL $xdatasym+064h
                            *   .pdata ENDS
00000268                        tstrcmp endp

00000268                        tmemcmp proc fastcall uses rsi rdi dst:ptr, src:ptr, size:uint_t

00000268                    *    push rsi
                            *    .pushreg rsi
00000269                    *    push rdi
                            *    .pushreg rdi
0000026A                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
0000026E                            mov     rdi,rcx
00000271                            mov     rsi,rdx
00000274                            mov     ecx,r8d
00000277                            xor     eax,eax
00000279                            repe    cmpsb
0000027B                            je      .0
0000027D                            sbb     eax,eax
0000027F                            sbb     eax,-1
00000282                        .0:
00000282                            ret
00000282                    *   add rsp, 8
00000286                    *   pop rdi
00000287                    *   pop rsi
00000288                    *   retn 

0000006C                    *   .xdata segment
                            *   db 1t + (00h shl 3), 6t, 3t, 00h + (00h shl 4)
                            *   dw 0206h, 07002h, 06001h
                            *   ALIGN 4
                            *   .xdata ENDS
0000009C                    *   .pdata SEGMENT
                            *   dd IMAGEREL tmemcmp, IMAGEREL tmemcmp+021h, IMAGEREL $xdatasym+06Ch
                            *   .pdata ENDS
00000289                        tmemcmp endp

00000289                        tmemicmp proc fastcall dst:ptr, src:ptr, size:uint_t
00000289                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
0000028D                        .0:
0000028D                            test    r8d,r8d
00000290                            jz      .1
00000292                            dec     r8d
00000295                            mov     al,[rcx+r8]
00000299                            cmp     al,[rdx+r8]
0000029D                            je      .0
0000029F                            mov     ah,al
000002A1                            mov     al,[rdx+r8]
000002A5                            or      eax,0x2020
000002AA                            cmp     ah,al
000002AC                            je      .0
000002AE                            sbb     r8d,r8d
000002B1                            sbb     r8d,-1
000002B5                        .1:
000002B5                            mov     eax,r8d
000002B8                            ret
000002B8                    *   add rsp, 8
000002BC                    *   retn 

00000078                    *   .xdata segment
                            *   db 1t + (00h shl 3), 4t, 1t, 00h + (00h shl 4)
                            *   dw 0204h
                            *   ALIGN 4
                            *   .xdata ENDS
000000A8                    *   .pdata SEGMENT
                            *   dd IMAGEREL tmemicmp, IMAGEREL tmemicmp+034h, IMAGEREL $xdatasym+078h
                            *   .pdata ENDS
000002BD                        tmemicmp endp

000002BD                        tstricmp proc fastcall a:string_t, b:string_t

000002BD                    *   sub rsp, 8
                            *   .allocstack 8
                            *   .endprolog
000002C1                            mov     eax,1
000002C6                            xor     r8d,r8d
000002C9                        .0:
000002C9                            test    al,al
000002CB                            jz      .1
000002CD                            mov     al,[rcx]
000002CF                            cmp     al,[rdx]
000002D1                            lea     rdx,[rdx+1]
000002D5                            lea     rcx,[rcx+1]
000002D9                            je      .0
000002DB                            mov     ah,[rdx-1]
000002DE                            or      eax,0x2020
000002E3                            cmp     al,ah
000002E5                            je      .0
000002E7                            sbb     r8d,r8d
000002EA                            sbb     r8d,-1
000002EE                        .1:
000002EE                            mov     eax,r8d
000002F1                            ret
000002F1                    *   add rsp, 8
000002F5                    *   retn 

00000080                    *   .xdata segment
                            *   db 1t + (00h shl 3), 4t, 1t, 00h + (00h shl 4)
                            *   dw 0204h
                            *   ALIGN 4
                            *   .xdata ENDS
000000B4                    *   .pdata SEGMENT
                            *   dd IMAGEREL tstricmp, IMAGEREL tstricmp+039h, IMAGEREL $xdatasym+080h
                            *   .pdata ENDS
000002F6                        tstricmp endp

000002F6                        tstrstr proc fastcall uses rsi rdi rbx dst:string_t, src:string_t

000002F6                    *    push rsi
                            *    .pushreg rsi
000002F7                    *    push rdi
                            *    .pushreg rdi
000002F8                    *    push rbx
                            *    .pushreg rbx
                            *   .endprolog
000002F9                            mov rdi,rcx
000002FC                            mov rbx,rdx

000002FF                            .if tstrlen(rbx)
000002FF                    *   invoke tstrlen, rbx
000002FF                    *    sub rsp, 32
00000303                    *    mov rcx, rbx
00000306                    *    call tstrlen
0000030B                    *    add rsp, 32
0000030F                    *   test rax, rax
00000312                    *   jz  @C0001

00000314                                mov rsi,rax
00000317                                .if tstrlen(rdi)
00000317                    *   invoke tstrlen, rdi
00000317                    *    sub rsp, 32
0000031B                    *    mov rcx, rdi
0000031E                    *    call tstrlen
00000323                    *    add rsp, 32
00000327                    *   test rax, rax
0000032A                    *   jz  @C0002

0000032C                                    mov rcx,rax
0000032F                                    xor eax,eax
00000331                                    dec rsi

00000334                                    .repeat
00000334                    *   @C0003:
00000334                                        mov al,[rbx]
00000336                                        repne scasb
00000338                                        mov al,0
0000033A                                        .break .ifnz
0000033A                    *   jnz @C0004
0000033C                                        .if rsi
0000033C                    *   test rsi, rsi
0000033F                    *   jz  @C0005
00000341                                            .break .if rcx < rsi
00000341                    *   cmp rcx , rsi
00000344                    *   jb  @C0004
00000346                                            mov rdx,rsi
00000349                                            .repeat
00000349                    *   @C0006:
00000349                                                mov al,[rbx+rdx]
0000034C                                                .continue(01) .if al != [rdi+rdx-1]
0000034C                    *   cmp al , [rdi+rdx-1]
00000350                    *   jnz @C0003
00000352                                                dec rdx
00000355                                            .untilz
00000355                    *   jne @C0006
00000357                                        .endif
00000357                    *   @C0005:
00000357                                        lea rax,[rdi-1]
0000035B                                    .until 1
0000035B                    *   @C0007:
0000035B                    *   @C0004:
0000035B                                .endif
0000035B                    *   @C0002:
0000035B                            .endif
0000035B                    *   @C0001:
0000035B                            ret
0000035B                    *   pop rbx
0000035C                    *   pop rdi
0000035D                    *   pop rsi
0000035E                    *   retn 

00000088                    *   .xdata segment
                            *   db 1t + (00h shl 3), 3t, 3t, 00h + (00h shl 4)
                            *   dw 03003h, 07002h, 06001h
                            *   ALIGN 4
                            *   .xdata ENDS
000000C0                    *   .pdata SEGMENT
                            *   dd IMAGEREL tstrstr, IMAGEREL tstrstr+069h, IMAGEREL $xdatasym+088h
                            *   .pdata ENDS
0000035F                        tstrstr endp

                                    option win64:rbp auto save

                                PQSORTCMD_T typedef proto fastcall :ptr, :ptr
0000035F                        PQSORTCMD   typedef ptr PQSORTCMD_T
                           D:\Asmc\source\asmc\x64\ltype.asm(559) : error A2004: symbol type conflict : PQSORTCMD

                            *   memxchg macro _1, _2, _3
 >                          *   .repeat
 >                          *   mov rax,[rcx]
 >                          *   mov r10,[rdx]
 >                          *   mov [rdx],rax
 >                          *   mov [rcx],r10
 >                          *   sub r8d,8
 >                          *   .until r8d < 8
 >                          *   exitm<>
 >                          *   endm
                                memxchg proto fastcall :ptr, :ptr, :int_t 

0000035F                        tqsort proc fastcall uses rsi rdi rbx r12 r13 r14 r15 p:ptr, n:int_t, w:int_t, compare:PQSORTCMD

0000035F                    *   mov [rsp+32], r9
00000364                    *   mov [rsp+24], r8
00000369                    *   mov [rsp+16], rdx
0000036E                    *   mov [rsp+8], rcx
00000373                    *    push rsi
                            *    .pushreg rsi
00000374                    *    push rdi
                            *    .pushreg rdi
00000375                    *    push rbx
                            *    .pushreg rbx
00000376                    *    push r12
                            *    .pushreg r12
00000378                    *    push r13
                            *    .pushreg r13
0000037A                    *    push r14
                            *    .pushreg r14
0000037C                    *    push r15
                            *    .pushreg r15
0000037E                    *    push rbp
                            *    .pushreg rbp
0000037F                    *    mov rbp, rsp
                            *    .setframe rbp, 0
00000382                    *   sub rsp, 8 + @ReservedStack
                            *   .allocstack 8 + @ReservedStack
                            *   .endprolog
00000386                            .if edx > 1
00000386                    *   cmp edx , 1
00000389                    *   jna @C0008

0000038B                                lea eax,[rdx-1]
0000038E                                mul r8d
00000391                                mov rsi,rcx
00000394                                lea rdi,[rsi+rax]
00000398                                xor r12,r12
0000039B                                mov r13d,r8d

0000039E                                .while 1
0000039E                    *   @C0009:

0000039E                                    mov ecx,r13d
000003A1                                    lea rax,[rdi+rcx]   ; middle from (hi - lo) / 2
000003A5                                    sub rax,rsi
000003A8                                    .ifnz
000003A8                    *   jz  @C000A
000003AA                                        xor rdx,rdx
000003AD                                        div rcx
000003B0                                        shr rax,1
000003B3                                        mul rcx
000003B6                                    .endif
000003B6                    *   @C000A:

000003B6                                    sub rsp,0x20

000003BA                                    lea rbx,[rsi+rax]

000003BE                                    .ifsd compare(rsi, rbx) > 0
000003BE                    *   invoke compare, rsi, rbx
000003BE                    *    mov rdx, rbx
000003C1                    *    mov rcx, rsi
000003C4                    *    call compare
000003C7                    *   cmp eax , 0
000003CA                    *   jng @C000B
000003CC                    *   invoke memxchg, rsi, rbx, r13d
000003CC                    *    mov r8d, r13d
000003CF                    *    mov rdx, rbx
000003D2                    *    mov rcx, rsi
000003D5                    *1  .repeat
000003D5                    *1  @C000C:
000003D5                    *1  mov rax,[rcx]
000003D8                    *1  mov r10,[rdx]
000003DB                    *1  mov [rdx],rax
000003DE                    *1  mov [rcx],r10
000003E1                    *1  sub r8d,8
000003E5                    *1  .until r8d < 8
000003E5                    *1  cmp r8d , 8
000003E9                    *1  jnb @C000C
                                invoke memxchg(rsi, rbx, r13d)
000003EB                                    .endif
000003EB                    *   @C000B:
000003EB                                    .ifsd compare(rsi, rdi) > 0
000003EB                    *   invoke compare, rsi, rdi
000003EB                    *    mov rdx, rdi
000003EE                    *    mov rcx, rsi
000003F1                    *    call compare
000003F4                    *   cmp eax , 0
000003F7                    *   jng @C000D
000003F9                    *   invoke memxchg, rsi, rdi, r13d
000003F9                    *    mov r8d, r13d
000003FC                    *    mov rdx, rdi
000003FF                    *    mov rcx, rsi
00000402                    *1  .repeat
00000402                    *1  @C000E:
00000402                    *1  mov rax,[rcx]
00000405                    *1  mov r10,[rdx]
00000408                    *1  mov [rdx],rax
0000040B                    *1  mov [rcx],r10
0000040E                    *1  sub r8d,8
00000412                    *1  .until r8d < 8
00000412                    *1  cmp r8d , 8
00000416                    *1  jnb @C000E
                                invoke memxchg(rsi, rdi, r13d)
00000418                                    .endif
00000418                    *   @C000D:
00000418                                    .ifsd compare(rbx, rdi) > 0
00000418                    *   invoke compare, rbx, rdi
00000418                    *    mov rdx, rdi
0000041B                    *    mov rcx, rbx
0000041E                    *    call compare
00000421                    *   cmp eax , 0
00000424                    *   jng @C000F
00000426                    *   invoke memxchg, rbx, rdi, r13d
00000426                    *    mov r8d, r13d
00000429                    *    mov rdx, rdi
0000042C                    *    mov rcx, rbx
0000042F                    *1  .repeat
0000042F                    *1  @C0010:
0000042F                    *1  mov rax,[rcx]
00000432                    *1  mov r10,[rdx]
00000435                    *1  mov [rdx],rax
00000438                    *1  mov [rcx],r10
0000043B                    *1  sub r8d,8
0000043F                    *1  .until r8d < 8
0000043F                    *1  cmp r8d , 8
00000443                    *1  jnb @C0010
                                invoke memxchg(rbx, rdi, r13d)
00000445                                    .endif
00000445                    *   @C000F:

00000445                                    mov r14,rsi
00000448                                    mov r15,rdi

0000044B                                    .while 1
0000044B                    *   @C0011:

0000044B                                        add r14,r13
0000044E                                        .if r14 < rdi
0000044E                    *   cmp r14 , rdi
00000451                    *   jnb @C0012

00000453                                            .continue .ifsd compare(r14, rbx) <= 0
00000453                    *   invoke compare, r14, rbx
00000453                    *    mov rdx, rbx
00000456                    *    mov rcx, r14
00000459                    *    call compare
0000045C                    *   cmp eax , 0
0000045F                    *   jng @C0011
00000461                                        .endif
00000461                    *   @C0012:

00000461                                        .while 1
00000461                    *   @C0013:

00000461                                            sub r15,r13

00000464                                            .break .if r15 <= rbx
00000464                    *   cmp r15 , rbx
00000467                    *   jna @C0014
00000469                                            .break .ifsd compare(r15, rbx) <= 0
00000469                    *   invoke compare, r15, rbx
00000469                    *    mov rdx, rbx
0000046C                    *    mov rcx, r15
0000046F                    *    call compare
00000472                    *   cmp eax , 0
00000475                    *   jng @C0014
00000477                                        .endw
00000477                    *   jmp @C0013
00000479                    *   @C0014:

00000479                                        mov rcx,r15
0000047C                                        mov rax,r14
0000047F                                        .break .if rcx < rax
0000047F                    *   cmp rcx , rax
00000482                    *   jb  @C0015
00000484                    *   invoke memxchg, rcx, rax, r13d
00000484                    *    mov r8d, r13d
00000487                    *    mov rdx, rax
0000048A                    *1  .repeat
0000048A                    *1  @C0016:
0000048A                    *1  mov rax,[rcx]
0000048D                    *1  mov r10,[rdx]
00000490                    *1  mov [rdx],rax
00000493                    *1  mov [rcx],r10
00000496                    *1  sub r8d,8
0000049A                    *1  .until r8d < 8
0000049A                    *1  cmp r8d , 8
0000049E                    *1  jnb @C0016
                                invoke memxchg(rcx, rax, r13d)

000004A0                                        .if rbx == r15
000004A0                    *   cmp rbx , r15
000004A3                    *   jnz @C0017

000004A5                                            mov rbx,r14
000004A8                                        .endif
000004A8                    *   @C0017:
000004A8                                    .endw
000004A8                    *   jmp @C0011
000004AA                    *   @C0015:

000004AA                                    add r15,r13

000004AD                                    .while 1
000004AD                    *   @C0018:

000004AD                                        sub r15,r13

000004B0                                        .break .if r15 <= rsi
000004B0                    *   cmp r15 , rsi
000004B3                    *   jna @C0019
000004B5                                        .break .ifd compare(r15, rbx)
000004B5                    *   invoke compare, r15, rbx
000004B5                    *    mov rdx, rbx
000004B8                    *    mov rcx, r15
000004BB                    *    call compare
000004BE                    *   test eax, eax
000004C0                    *   jnz @C0019
000004C2                                    .endw
000004C2                    *   jmp @C0018
000004C4                    *   @C0019:

000004C4                                    add rsp,0x20

000004C8                                    mov rdx,r14
000004CB                                    mov rax,r15
000004CE                                    sub rax,rsi
000004D1                                    mov rcx,rdi
000004D4                                    sub rcx,rdx

000004D7                                    .ifs rax < rcx
000004D7                    *   cmp rax , rcx
000004DA                    *   jnl @C001A

000004DC                                        mov rcx,r15

000004DF                                        .if rdx < rdi
000004DF                    *   cmp rdx , rdi
000004E2                    *   jnb @C001B

000004E4                                            push rdx
000004E5                                            push rdi
000004E6                                            inc r12d
000004E9                                        .endif
000004E9                    *   @C001B:

000004E9                                        .if rsi < rcx
000004E9                    *   cmp rsi , rcx
000004EC                    *   jnb @C001C

000004EE                                            mov rdi,rcx
000004F1                                            .continue
000004F1                    *   jmp @C0009
000004F6                                        .endif
000004F6                    *   @C001C:
000004F6                                    .else
000004F6                    *   jmp @C001D
000004F8                    *   @C001A:
000004F8                                        mov rcx,r15

000004FB                                        .if rsi < rcx
000004FB                    *   cmp rsi , rcx
000004FE                    *   jnb @C001E

00000500                                            push rsi
00000501                                            push rcx
00000502                                            inc r12d
00000505                                        .endif
00000505                    *   @C001E:

00000505                                        .if rdx < rdi
00000505                    *   cmp rdx , rdi
00000508                    *   jnb @C001F

0000050A                                            mov rsi,rdx
0000050D                                            .continue
0000050D                    *   jmp @C0009
00000512                                        .endif
00000512                    *   @C001F:
00000512                                    .endif
00000512                    *   @C001D:

00000512                                    .break .if !r12d
00000512                    *   test r12d, r12d
00000515                    *   jz  @C0020

00000517                                    dec r12d
0000051A                                    pop rdi
0000051B                                    pop rsi
0000051C                                .endw
0000051C                    *   jmp @C0009
00000521                    *   @C0020:
00000521                            .endif
00000525                    *   @C0008:
00000525                            ret
00000525                    *   leave
00000526                    *   pop r15
00000528                    *   pop r14
0000052A                    *   pop r13
0000052C                    *   pop r12
0000052E                    *   pop rbx
0000052F                    *   pop rdi
00000530                    *   pop rsi
00000531                    *   retn 

00000094                    *   .xdata segment
                            *   db 1t + (00h shl 3), 39t, 10t, 05h + (00h shl 4)
                            *   dw 04227h, 05323h, 05020h, 0F01Fh, 0E01Dh, 0D01Bh, 0C019h, 03017h, 07016h
                            *   dw 06015h
                            *   ALIGN 4
                            *   .xdata ENDS
000000CC                    *   .pdata SEGMENT
                            *   dd IMAGEREL tqsort, IMAGEREL tqsort+01D3h, IMAGEREL $xdatasym+094h
                            *   .pdata ENDS
00000532                        tqsort endp

                                    end
                            *   _TEXT ends


Macros:

                N a m e                 Type

@CStr  . . . . . . . . . . . . .        Func
@CatStr  . . . . . . . . . . . .        Func
@ComAlloc  . . . . . . . . . . .        Func
@Environ . . . . . . . . . . . .        Func
@InStr . . . . . . . . . . . . .        Func
@SizeStr . . . . . . . . . . . .        Func
@SubStr  . . . . . . . . . . . .        Func
CALLBACK . . . . . . . . . . . .        Func
CALLBACKC  . . . . . . . . . . .        Func
CCALLBACK  . . . . . . . . . . .        Func
SymSearch  . . . . . . . . . . .        Func
UNREFERENCED_PARAMETER . . . . .        Func
_PTR_LD  . . . . . . . . . . . .        Func
asm_tok_tokptr . . . . . . . . .        Func
typeid . . . . . . . . . . . . .        Func


Structures and Unions:

                N a m e                 Size/Ofs   Type

_CRT_DOUBLE  . . . . . . . . . .               8 (8)
  x  . . . . . . . . . . . . . .               0   QWord
_CRT_FLOAT . . . . . . . . . . .               4 (8)
  f  . . . . . . . . . . . . . .               0   DWord
_LDBL12  . . . . . . . . . . . .               C (4)
  ld12 . . . . . . . . . . . . .               0   Byte[12]
_LDOUBLE . . . . . . . . . . . .               A (4)
  ld . . . . . . . . . . . . . .               0   Byte[10]
_LONGDOUBLE  . . . . . . . . . .              10 (8)
  x  . . . . . . . . . . . . . .               0   TByte
_div_t . . . . . . . . . . . . .               8 (8)
  quot . . . . . . . . . . . . .               0   int_t
  rem  . . . . . . . . . . . . .               4   int_t
_iobuf . . . . . . . . . . . . .              30 (8)
  _ptr . . . . . . . . . . . . .               0   LPSTR
  _cnt . . . . . . . . . . . . .               8   SINT
  _base  . . . . . . . . . . . .              10   LPSTR
  _flag  . . . . . . . . . . . .              18   SINT
  _file  . . . . . . . . . . . .              1C   SINT
  _charbuf . . . . . . . . . . .              20   SINT
  _bufsiz  . . . . . . . . . . .              24   SINT
  _tmpfname  . . . . . . . . . .              28   LPSTR
_ldiv_t  . . . . . . . . . . . .               8 (8)
  quot . . . . . . . . . . . . .               0   long_t
  rem  . . . . . . . . . . . . .               4   long_t
_lldiv_t . . . . . . . . . . . .              10 (8)
  quot . . . . . . . . . . . . .               0   int64_t
  rem  . . . . . . . . . . . . .               8   int64_t
_locale_tstruct  . . . . . . . .              10 (8)
  locinfo  . . . . . . . . . . .               0   ptr?threadlocinfo
  mbcinfo  . . . . . . . . . . .               8   ptr?threadmbcinfo
asm_tok  . . . . . . . . . . . .              18 (8)
  token  . . . . . . . . . . . .               0   uchar_t
 . . . . . . . . . . . . . . . .               1 (8)
    dirtype  . . . . . . . . . .               1   uchar_t
    bytval . . . . . . . . . . .               1   uchar_t
    precedence . . . . . . . . .               1   uchar_t
    string_delim . . . . . . . .               1   char_t
    floattype  . . . . . . . . .               1   char_t
    numbase  . . . . . . . . . .               1   char_t
    specval  . . . . . . . . . .               1   char_t
  hll_flags  . . . . . . . . . .               2   uchar_t
  hll_index  . . . . . . . . . .               3   uchar_t
 . . . . . . . . . . . . . . . .               4 (8)
    tokval . . . . . . . . . . .               4   uint_t
    stringlen  . . . . . . . . .               4   uint_t
    idarg  . . . . . . . . . . .               4   uint_t
    itemlen  . . . . . . . . . .               4   uint_t
    lastidx  . . . . . . . . . .               4   uint_t
  string_ptr . . . . . . . . . .               8   string_t
  tokpos . . . . . . . . . . . .              10   string_t
asm_tokVtbl  . . . . . . . . . .               8 (8)
  tokptr . . . . . . . . . . . .               0   P$0001
asym . . . . . . . . . . . . . .              68 (8)
  nextitem . . . . . . . . . . .               0   ptr?asym
  name . . . . . . . . . . . . .               8   string_t
  name_size  . . . . . . . . . .              10   int_t
  state  . . . . . . . . . . . .              14   uchar_t
  mem_type . . . . . . . . . . .              15   uchar_t
  langtype . . . . . . . . . . .              16   uchar_t
  flags  . . . . . . . . . . . .              17   uchar_t
  flag1  . . . . . . . . . . . .              18   uchar_t
  flag2  . . . . . . . . . . . .              19   uchar_t
  segoffsize . . . . . . . . . .              1A   uchar_t
  is_far . . . . . . . . . . . .              1B   uchar_t
  type . . . . . . . . . . . . .              20   ptr?asym
 . . . . . . . . . . . . . . . .               8 (8)
    offs . . . . . . . . . . . .              28   int_t
    value  . . . . . . . . . . .              28   int_t
    uvalue . . . . . . . . . . .              28   uint_t
    string_ptr . . . . . . . . .              28   string_t
    substitute . . . . . . . . .              28   ptr?asym
    func_ptr . . . . . . . . . .              28   P$0002
    classlnameidx  . . . . . . .              28   int_t
 . . . . . . . . . . . . . . . .               8 (8)
    segm . . . . . . . . . . . .              30   ptr?asym
    class  . . . . . . . . . . .              30   ptr?asym
    vtable . . . . . . . . . . .              30   ptr?asym
    vmacro . . . . . . . . . . .              30   ptr?asym
 . . . . . . . . . . . . . . . .               4 (8)
    first_size . . . . . . . . .              38   uint_t
 . . . . . . . . . . . . . . . .               4 (8)
      Ofssize  . . . . . . . . .              38   uchar_t
      is_ptr . . . . . . . . . .              39   uchar_t
 . . . . . . . . . . . . . . . .               1 (8)
        ptr_memtype  . . . . . .              3A   uchar_t
        asmpass  . . . . . . . .              3A   uchar_t
      sflags . . . . . . . . . .              3B   uchar_t
    mac_flag . . . . . . . . . .              38   uchar_t
 . . . . . . . . . . . . . . . .               8 (8)
    first_length . . . . . . . .              40   uint_t
    max_mbr_size . . . . . . . .              40   uint_t
    target_type  . . . . . . . .              40   ptr?asym
  regist . . . . . . . . . . . .              48   ushort_t[2]
 . . . . . . . . . . . . . . . .               8 (8)
    total_size . . . . . . . . .              50   uint_t
    value3264  . . . . . . . . .              50   int_t
    dll  . . . . . . . . . . . .              50   ptr?dll_desc
    max_offset . . . . . . . . .              50   int_t
 . . . . . . . . . . . . . . . .               8 (8)
    total_length . . . . . . . .              58   uint_t
    altname  . . . . . . . . . .              58   ptr?asym
    debuginfo  . . . . . . . . .              58   ptr?debug_info
    sfunc_ptr  . . . . . . . . .              58   P$0003
 . . . . . . . . . . . . . . . .               4 (8)
      cvtyperef  . . . . . . . .              58   ushort_t
      typekind . . . . . . . . .              5A   ushort_t
 . . . . . . . . . . . . . . . .               8 (8)
    bp_fixup . . . . . . . . . .              60   ptr?fixup
    ext_idx  . . . . . . . . . .              60   uint_t
 . . . . . . . . . . . . . . . .               4 (8)
      ext_idx1 . . . . . . . . .              60   ushort_t
      ext_idx2 . . . . . . . . .              62   ushort_t
com_item . . . . . . . . . . . .              30 (8)
  cmd  . . . . . . . . . . . . .               0   DWord
  class  . . . . . . . . . . . .               8   string_t
  langtype . . . . . . . . . . .              10   DWord
  publsym  . . . . . . . . . . .              18   ptr?asym
  method . . . . . . . . . . . .              20   DWord
  sym  . . . . . . . . . . . . .              28   ptr?asym
debug_info . . . . . . . . . . .              18 (8)
  start_line . . . . . . . . . .               0   DWord
  end_line . . . . . . . . . . .               4   DWord
  ln_fileofs . . . . . . . . . .               8   DWord
  line_numbers . . . . . . . . .               C   Word
  file . . . . . . . . . . . . .               E   Word
  next_proc  . . . . . . . . . .              10   DWord
  next_file  . . . . . . . . . .              14   DWord
dll_desc . . . . . . . . . . . .              10 (8)
  next . . . . . . . . . . . . .               0   ptr?dll_desc
  cnt  . . . . . . . . . . . . .               8   int_t
  name . . . . . . . . . . . . .               C   char_t
dsym . . . . . . . . . . . . . .              80 (8)
   . . . . . . . . . . . . . . .               0   asym
 . . . . . . . . . . . . . . . .               8 (8)
    seginfo  . . . . . . . . . .              68   ptr?seg_item
    grpinfo  . . . . . . . . . .              68   ptr?grp_info
    procinfo . . . . . . . . . .              68   ptr?proc_info
    structinfo . . . . . . . . .              68   ptr?struct_info
    macroinfo  . . . . . . . . .              68   ptr?macro_info
    nextll . . . . . . . . . . .              68   ptr?dsym
  next . . . . . . . . . . . . .              70   ptr?dsym
 . . . . . . . . . . . . . . . .               8 (8)
    prev . . . . . . . . . . . .              78   ptr?dsym
    nextproc . . . . . . . . . .              78   ptr?dsym
    nextlocal  . . . . . . . . .              78   ptr?dsym
    nextparam  . . . . . . . . .              78   ptr?dsym
format_options . . . . . . . . .              10 (8)
  init . . . . . . . . . . . . .               0   P$0005
  invalid_fixup_type . . . . . .               8   Word
  formatname . . . . . . . . . .               A   char_t[6]
global_options . . . . . . . . .              C0 (8)
  quiet  . . . . . . . . . . . .               0   Byte
  line_numbers . . . . . . . . .               1   Byte
  debug_symbols  . . . . . . . .               2   Byte
  debug_ext  . . . . . . . . . .               3   Byte
  floating_point . . . . . . . .               4   DWord
  error_limit  . . . . . . . . .               8   DWord
  no_error_disp  . . . . . . . .               C   Byte
  warning_level  . . . . . . . .               D   Byte
  warning_error  . . . . . . . .               E   Byte
  process_subdir . . . . . . . .               F   Byte
  names  . . . . . . . . . . . .              10   string_t[9]
  queues . . . . . . . . . . . .              58   ptr_t[3]
  no_comment_in_code_rec . . . .              70   Byte
  no_opt_farcall . . . . . . . .              71   Byte
  no_file_entry  . . . . . . . .              72   Byte
  no_static_procs  . . . . . . .              73   Byte
  no_section_aux_entry . . . . .              74   Byte
  no_cdecl_decoration  . . . . .              75   Byte
  stdcall_decoration . . . . . .              76   Byte
  no_export_decoration . . . . .              77   Byte
  entry_decorated  . . . . . . .              78   Byte
  write_listing  . . . . . . . .              79   Byte
  write_impdef . . . . . . . . .              7A   Byte
  case_sensitive . . . . . . . .              7B   Byte
  convert_uppercase  . . . . . .              7C   Byte
  preprocessor_stdout  . . . . .              7D   Byte
  masm51_compat  . . . . . . . .              7E   Byte
  strict_masm_compat . . . . . .              7F   Byte
  masm_compat_gencode  . . . . .              80   Byte
  masm8_proc_visibility  . . . .              81   Byte
  listif . . . . . . . . . . . .              82   Byte
  list_generated_code  . . . . .              83   Byte
  list_macro . . . . . . . . . .              84   DWord
  no_symbol_listing  . . . . . .              88   Byte
  first_pass_listing . . . . . .              89   Byte
  all_symbols_public . . . . . .              8A   Byte
  safeseh  . . . . . . . . . . .              8B   Byte
  output_format  . . . . . . . .              8C   DWord
  sub_format . . . . . . . . . .              90   DWord
  langtype . . . . . . . . . . .              94   DWord
  _model . . . . . . . . . . . .              98   DWord
  cpu  . . . . . . . . . . . . .              9C   DWord
  fctype . . . . . . . . . . . .              A0   DWord
  codepage . . . . . . . . . . .              A4   DWord
  ignore_include . . . . . . . .              A8   Byte
  fieldalign . . . . . . . . . .              A9   Byte
  syntax_check_only  . . . . . .              AA   Byte
  xflag  . . . . . . . . . . . .              AB   Byte
  loopalign  . . . . . . . . . .              AC   Byte
  casealign  . . . . . . . . . .              AD   Byte
  epilogueflags  . . . . . . . .              AE   Byte
  segmentalign . . . . . . . . .              AF   Byte
  pe_subsystem . . . . . . . . .              B0   Byte
  win64_flags  . . . . . . . . .              B1   Byte
  chkstack . . . . . . . . . . .              B2   Byte
  nolib  . . . . . . . . . . . .              B3   Byte
  masm_keywords  . . . . . . . .              B4   Byte
  arch . . . . . . . . . . . . .              B5   Byte
  frame_auto . . . . . . . . . .              B6   Byte
  floatformat  . . . . . . . . .              B7   Byte
  floatdigits  . . . . . . . . .              B8   DWord
  flt_size . . . . . . . . . . .              BC   Byte
grp_info . . . . . . . . . . . .              18 (8)
  seglist  . . . . . . . . . . .               0   ptr?seg_item
  grp_idx  . . . . . . . . . . .               8   int_t
  lname_idx  . . . . . . . . . .               C   int_t
  numseg . . . . . . . . . . . .              10   uint_t
locrefcount  . . . . . . . . . .              20 (8)
  locale . . . . . . . . . . . .               0   LPSTR
  wlocale  . . . . . . . . . . .               8   LPWSTR
  refcount . . . . . . . . . . .              10   LPINT
  wrefcount  . . . . . . . . . .              18   LPINT
macro_info . . . . . . . . . . .              20 (8)
  parmcnt  . . . . . . . . . . .               0   ushort_t
 . . . . . . . . . . . . . . . .               2 (8)
    localcnt . . . . . . . . . .               2   ushort_t
    autoexp  . . . . . . . . . .               2   ushort_t
  parmlist . . . . . . . . . . .               8   ptr?mparm_list
  lines  . . . . . . . . . . . .              10   ptr?srcline
  srcfile  . . . . . . . . . . .              18   uint_t
module_info  . . . . . . . . . .             350 (8)
   . . . . . . . . . . . . . . .               0   module_vars
  proc_prologue  . . . . . . . .             178   string_t
  proc_epilogue  . . . . . . . .             180   string_t
  CurrDll  . . . . . . . . . . .             188   ptr?dll_desc
  fmtopt . . . . . . . . . . . .             190   ptr?format_options
  hll_label  . . . . . . . . . .             198   DWord
  distance . . . . . . . . . . .             19C   Byte
  _model . . . . . . . . . . . .             19D   Byte
  langtype . . . . . . . . . . .             19E   Byte
  ostype . . . . . . . . . . . .             19F   Byte
  sub_format . . . . . . . . . .             1A0   Byte
  fctype . . . . . . . . . . . .             1A1   Byte
  segorder . . . . . . . . . . .             1A2   Byte
  offsettype . . . . . . . . . .             1A3   Byte
  cpu  . . . . . . . . . . . . .             1A4   DWord
  curr_cpu . . . . . . . . . . .             1A8   DWord
  radix  . . . . . . . . . . . .             1AC   Byte
  fieldalign . . . . . . . . . .             1AD   Byte
  line_flags . . . . . . . . . .             1AE   Byte
  procalign  . . . . . . . . . .             1AF   Byte
  list_macro . . . . . . . . . .             1B0   DWord
  Ofssize  . . . . . . . . . . .             1B4   Byte
  defOfssize . . . . . . . . . .             1B5   Byte
  wordsize . . . . . . . . . . .             1B6   Byte
  inside_comment . . . . . . . .             1B7   Byte
  case_sensitive . . . . . . . .             1B8   Byte
  convert_uppercase  . . . . . .             1B9   Byte
  procs_private  . . . . . . . .             1BA   Byte
  procs_export . . . . . . . . .             1BB   Byte
  dotname  . . . . . . . . . . .             1BC   Byte
  ljmp . . . . . . . . . . . . .             1BD   Byte
  m510 . . . . . . . . . . . . .             1BE   Byte
  scoped . . . . . . . . . . . .             1BF   Byte
  oldstructs . . . . . . . . . .             1C0   Byte
  emulator . . . . . . . . . . .             1C1   Byte
  setif2 . . . . . . . . . . . .             1C2   Byte
  list . . . . . . . . . . . . .             1C3   Byte
  cref . . . . . . . . . . . . .             1C4   Byte
  listif . . . . . . . . . . . .             1C5   Byte
  list_generated_code  . . . . .             1C6   Byte
  StartupDirectiveFound  . . . .             1C7   Byte
  EndDirFound  . . . . . . . . .             1C8   Byte
  frame_auto . . . . . . . . . .             1C9   Byte
  NoSignExtend . . . . . . . . .             1CA   Byte
  simseg_init  . . . . . . . . .             1CB   Byte
 . . . . . . . . . . . . . . . .               8 (8)
 . . . . . . . . . . . . . . . .               2 (8)
      elf_osabi  . . . . . . . .             1CC   Byte
      win64_flags  . . . . . . .             1CD   Byte
 . . . . . . . . . . . . . . . .               8 (8)
      mz_ofs_fixups  . . . . . .             1CC   Word
      mz_alignment . . . . . . .             1CE   Word
      mz_heapmin . . . . . . . .             1D0   Word
      mz_heapmax . . . . . . . .             1D2   Word
  simseg_defd  . . . . . . . . .             1D4   Byte
  PhaseError . . . . . . . . . .             1D5   Byte
  CommentDataInCode  . . . . . .             1D6   Byte
  prologuemode . . . . . . . . .             1D7   Byte
  epiloguemode . . . . . . . . .             1D8   Byte
  invoke_exprparm  . . . . . . .             1D9   Byte
  cv_opt . . . . . . . . . . . .             1DA   Byte
  strict_masm_compat . . . . . .             1DB   Byte
  srcfile  . . . . . . . . . . .             1DC   uint_t
  currseg  . . . . . . . . . . .             1E0   ptr?dsym
  flat_grp . . . . . . . . . . .             1E8   ptr?dsym
  pCodeBuff  . . . . . . . . . .             1F0   ptr?byte
  GeneratedCode  . . . . . . . .             1F8   uint_t
  currsource . . . . . . . . . .             200   string_t
  CurrComment  . . . . . . . . .             208   string_t
  tokenarray . . . . . . . . . .             210   ptr?asm_tok
  stringbufferend  . . . . . . .             218   string_t
  token_count  . . . . . . . . .             220   int_t
  basereg  . . . . . . . . . . .             224   uint_t[3]
  name . . . . . . . . . . . . .             230   Byte[260]
  xflag  . . . . . . . . . . . .             334   Byte
  loopalign  . . . . . . . . . .             335   Byte
  casealign  . . . . . . . . . .             336   Byte
  epilogueflags  . . . . . . . .             337   Byte
  assert_proc  . . . . . . . . .             338   string_t
  codepage . . . . . . . . . . .             340   uint_t
  class_label  . . . . . . . . .             344   uint_t
  floatformat  . . . . . . . . .             348   Byte
  flt_size . . . . . . . . . . .             349   Byte
  floatdigits  . . . . . . . . .             34C   int_t
module_vars  . . . . . . . . . .             178 (8)
  error_count  . . . . . . . . .               0   uint_t
  warning_count  . . . . . . . .               4   uint_t
  num_segs . . . . . . . . . . .               8   uint_t
  PubQueue . . . . . . . . . . .              10   qdesc
  LnameQueue . . . . . . . . . .              20   qdesc
  SafeSEHQueue . . . . . . . . .              30   qdesc
  LibQueue . . . . . . . . . . .              40   qdesc
  LinkQueue  . . . . . . . . . .              50   qdesc
  DllQueue . . . . . . . . . . .              60   ptr?dll_desc
  imp_prefix . . . . . . . . . .              68   string_t
  curr_file  . . . . . . . . . .              70   LPFILE[4]
  curr_fname . . . . . . . . . .              90   string_t[4]
  FNames . . . . . . . . . . . .              B0   array_t
  cnt_fnames . . . . . . . . . .              B8   uint_t
  IncludePath  . . . . . . . . .              C0   string_t
  line_queue . . . . . . . . . .              C8   qdesc
  src_stack  . . . . . . . . . .              D8   ptr?src_item
 . . . . . . . . . . . . . . . .               8 (8)
    start_fixup  . . . . . . . .              E0   ptr?fixup
    start_label  . . . . . . . .              E0   ptr?asym
  start_displ  . . . . . . . . .              E8   uint_t
  StrStack . . . . . . . . . . .              F0   ptr?str_item
  HllStack . . . . . . . . . . .              F8   ptr?hll_item
  HllFree  . . . . . . . . . . .             100   ptr?hll_item
  ComStack . . . . . . . . . . .             108   ptr?com_item
  RetStack . . . . . . . . . . .             110   ptr?hll_item
  FltStack . . . . . . . . . . .             118   ptr?flt_item
  NspStack . . . . . . . . . . .             120   ptr?nsp_item
  ContextStack . . . . . . . . .             128   ptr?byte
  ContextFree  . . . . . . . . .             130   ptr?byte
  SavedContexts  . . . . . . . .             138   ptr?byte
  cntSavedContexts . . . . . . .             140   int_t
  anonymous_label  . . . . . . .             144   uint_t
  StackBase  . . . . . . . . . .             148   ptr?asym
  ProcStatus . . . . . . . . . .             150   ptr?asym
  WriteModule  . . . . . . . . .             158   P$0006
  EndDirHook . . . . . . . . . .             160   P$0007
  Pass1Checks  . . . . . . . . .             168   P$0008
  pe_flags . . . . . . . . . . .             170   uint_t
  max_line_len . . . . . . . . .             174   uint_t
mparm_list . . . . . . . . . . .              10 (8)
  deflt  . . . . . . . . . . . .               0   string_t
  required . . . . . . . . . . .               8   uchar_t
nsp_item . . . . . . . . . . . .              10 (8)
  next . . . . . . . . . . . . .               0   ptr?nsp_item
  name . . . . . . . . . . . . .               8   ptr?sbyte
proc_info  . . . . . . . . . . .              48 (8)
  regslist . . . . . . . . . . .               0   ptr?word
  paralist . . . . . . . . . . .               8   ptr?dsym
  locallist  . . . . . . . . . .              10   ptr?dsym
  labellist  . . . . . . . . . .              18   ptr?dsym
  parasize . . . . . . . . . . .              20   uint_t
  localsize  . . . . . . . . . .              24   uint_t
  prologuearg  . . . . . . . . .              28   string_t
  exc_handler  . . . . . . . . .              30   ptr?asym
  ReservedStack  . . . . . . . .              38   int_t
  prolog_list_pos  . . . . . . .              3C   uint_t
  flags  . . . . . . . . . . . .              40   uchar_t
  size_prolog  . . . . . . . . .              41   uchar_t
  basereg  . . . . . . . . . . .              42   ushort_t
qdesc  . . . . . . . . . . . . .              10 (8)
  head . . . . . . . . . . . . .               0   ptr?
  tail . . . . . . . . . . . . .               8   ptr?
qditem . . . . . . . . . . . . .              10 (8)
  next . . . . . . . . . . . . .               0   ptr?qditem
  size . . . . . . . . . . . . .               8   uint_t
qitem  . . . . . . . . . . . . .              10 (8)
  next . . . . . . . . . . . . .               0   ptr?qitem
  value  . . . . . . . . . . . .               8   Byte
qnode  . . . . . . . . . . . . .              10 (8)
  next . . . . . . . . . . . . .               0   ptr?
 . . . . . . . . . . . . . . . .               8 (8)
    elmt . . . . . . . . . . . .               8   ptr?
    sym  . . . . . . . . . . . .               8   ptr?asym
seg_info . . . . . . . . . . . .              78 (8)
  sgroup . . . . . . . . . . . .               0   ptr?asym
  start_loc  . . . . . . . . . .               8   uint_t
 . . . . . . . . . . . . . . . .               4 (8)
    current_loc  . . . . . . . .               C   uint_t
    reloc_offset . . . . . . . .               C   uint_t
    start_offset . . . . . . . .               C   uint_t
  CodeBuffer . . . . . . . . . .              10   string_t
  bytes_written  . . . . . . . .              18   uint_t
 . . . . . . . . . . . . . . . .               8 (8)
    label_list . . . . . . . . .              20   asym_t
    flushfunc  . . . . . . . . .              20   P$0004
  head . . . . . . . . . . . . .              28   ptr?fixup
  tail . . . . . . . . . . . . .              30   ptr?fixup
 . . . . . . . . . . . . . . . .               8 (8)
    LinnumQueue  . . . . . . . .              38   ptr_t
    fileoffset . . . . . . . . .              38   uint_t
    num_linnums  . . . . . . . .              38   uint_t
  num_relocs . . . . . . . . . .              40   uint_t
  seg_idx  . . . . . . . . . . .              44   uint_t
  segtype  . . . . . . . . . . .              48   uint_t
  lname_idx  . . . . . . . . . .              4C   int_t
  clsym  . . . . . . . . . . . .              50   ptr?asym
 . . . . . . . . . . . . . . . .               4 (8)
    abs_frame  . . . . . . . . .              58   uint_t
    comdat_number  . . . . . . .              58   uint_t
    comdat_idx . . . . . . . . .              58   uint_t
 . . . . . . . . . . . . . . . .               8 (8)
    abs_offset . . . . . . . . .              60   uint_t
    aliasname  . . . . . . . . .              60   string_t
  Ofssize  . . . . . . . . . . .              68   uchar_t
  characteristics  . . . . . . .              69   uchar_t
  alignment  . . . . . . . . . .              6A   uchar_t
  readonly . . . . . . . . . . .              6B   uchar_t
  info . . . . . . . . . . . . .              6C   uchar_t
  force32  . . . . . . . . . . .              6D   uchar_t
  data_in_code . . . . . . . . .              6E   uchar_t
  internal . . . . . . . . . . .              6F   uchar_t
  written  . . . . . . . . . . .              70   uchar_t
  linnum_init  . . . . . . . . .              71   uchar_t
  combine  . . . . . . . . . . .              72   uchar_t
  comdatselection  . . . . . . .              73   uchar_t
seg_item . . . . . . . . . . . .              10 (8)
  next . . . . . . . . . . . . .               0   ptr?seg_item
  iseg . . . . . . . . . . . . .               8   ptr?dsym
sfield . . . . . . . . . . . . .              78 (8)
   . . . . . . . . . . . . . . .               0   asym
  next . . . . . . . . . . . . .              68   ptr?sfield
  ivalue . . . . . . . . . . . .              70   char_t
src_item . . . . . . . . . . . .              20 (8)
  next . . . . . . . . . . . . .               0   ptr?src_item
  type . . . . . . . . . . . . .               8   Word
  srcfile  . . . . . . . . . . .               A   Word
 . . . . . . . . . . . . . . . .               8 (8)
    content  . . . . . . . . . .              10   ptr_t
    file . . . . . . . . . . . .              10   ptr_t
    mi . . . . . . . . . . . . .              10   ptr_t
  line_num . . . . . . . . . . .              18   uint_t
srcline  . . . . . . . . . . . .              10 (8)
  next . . . . . . . . . . . . .               0   ptr?srcline
  ph_count . . . . . . . . . . .               8   uchar_t
  line . . . . . . . . . . . . .               9   char_t[1]
struct_info  . . . . . . . . . .              18 (8)
  head . . . . . . . . . . . . .               0   ptr?sfield
  tail . . . . . . . . . . . . .               8   ptr?sfield
  alignment  . . . . . . . . . .              10   uchar_t
  flags  . . . . . . . . . . . .              11   uchar_t
threadlocinfo  . . . . . . . . .             158 (8)
  refcount . . . . . . . . . . .               0   SINT
  lc_codepage  . . . . . . . . .               4   UINT
  lc_collate_cp  . . . . . . . .               8   UINT
  lc_time_cp . . . . . . . . . .               C   UINT
  lc_category  . . . . . . . . .              10   locrefcount[6]
  lc_clike . . . . . . . . . . .              D0   SINT
  mb_cur_max . . . . . . . . . .              D4   SINT
  lconv_intl_refcount  . . . . .              D8   LPINT
  lconv_num_refcount . . . . . .              E0   LPINT
  lconv_mon_refcount . . . . . .              E8   LPINT
  lconvp . . . . . . . . . . . .              F0   PVOID
  ctype1_refcount  . . . . . . .              F8   LPINT
  ctype1 . . . . . . . . . . . .             100   LPSHORT
  pctype . . . . . . . . . . . .             108   LPSHORT
  pclmap . . . . . . . . . . . .             110   LPSTR
  pcumap . . . . . . . . . . . .             118   LPSTR
  lc_time_curr . . . . . . . . .             120   ptr?__lc_time_data
  locale_name  . . . . . . . . .             128   LPWSTR[6]


Types:

                N a m e                 Size    Attr

?LPQSORTCMD  . . . . . . . . . .           8  Proc L Near64 FASTCALL
?PQSORTCMD . . . . . . . . . . .           8  Proc L Near64 FASTCALL
?_PtFuncCompare  . . . . . . . .           8  Proc L Near64 FASTCALL
?_PtFuncCompare_s  . . . . . . .           8  Proc L Near64 FASTCALL
?_invalid_parameter_handler  . .           8  Proc L Near64 FASTCALL
?_onexit_t . . . . . . . . . . .           8  Proc L Near64 FASTCALL
?_purecall_handler . . . . . . .           8  Proc L Near64 FASTCALL
FILE . . . . . . . . . . . . . .          48  _iobuf
HANDLE . . . . . . . . . . . . .           8  Near Ptr 
LPBYTE . . . . . . . . . . . . .           8  Near Ptr Byte
LPDWORD  . . . . . . . . . . . .           8  Near Ptr DWord
LPFILE . . . . . . . . . . . . .           8  Near Ptr _iobuf
LPINT  . . . . . . . . . . . . .           8  Near Ptr DWord
LPQSORTCMD . . . . . . . . . . .           8  Near Ptr 
LPQWORD  . . . . . . . . . . . .           8  Near Ptr QWord
LPSHORT  . . . . . . . . . . . .           8  Near Ptr Word
LPSTR  . . . . . . . . . . . . .           8  Near Ptr Byte
LPTSTR . . . . . . . . . . . . .           8  Near Ptr Byte
LPWORD . . . . . . . . . . . . .           8  Near Ptr Word
LPWSTR . . . . . . . . . . . . .           8  Near Ptr Word
P$0001 . . . . . . . . . . . . .           8  Near Ptr 
P$0002 . . . . . . . . . . . . .           8  Near Ptr 
P$0003 . . . . . . . . . . . . .           8  Near Ptr 
P$0004 . . . . . . . . . . . . .           8  Near Ptr 
P$0005 . . . . . . . . . . . . .           8  Near Ptr 
P$0006 . . . . . . . . . . . . .           8  Near Ptr 
P$0007 . . . . . . . . . . . . .           8  Near Ptr 
P$0008 . . . . . . . . . . . . .           8  Near Ptr 
PQSORTCMD  . . . . . . . . . . .           8  Near Ptr 
PQSORTCMD_T  . . . . . . . . . .           8  Proc L Near64 FASTCALL
PTBYTE . . . . . . . . . . . . .           8  Near Ptr Byte
PTCHAR . . . . . . . . . . . . .           8  Near Ptr Byte
PVOID  . . . . . . . . . . . . .           8  Near Ptr 
SINT . . . . . . . . . . . . . .           4  DWord
SIZE_T . . . . . . . . . . . . .           8  QWord
StrCmpFunc . . . . . . . . . . .           8  Near Ptr 
StrCmpFunc_t . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0001 . . . . . . . . . . . . .           8  Proc L Near64 WATCALL
T$0002 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0003 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0004 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0005 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0006 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0007 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0008 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
TCHAR  . . . . . . . . . . . . .           1  Byte
UINT . . . . . . . . . . . . . .           4  DWord
ULONG  . . . . . . . . . . . . .           4  DWord
_PtFuncCompare . . . . . . . . .           8  Near Ptr 
_PtFuncCompare_s . . . . . . . .           8  Near Ptr 
_invalid_parameter_handler . . .           8  Near Ptr 
_locale_t  . . . . . . . . . . .           8  Near Ptr _locale_tstruct
_onexit_t  . . . . . . . . . . .           8  Near Ptr 
_purecall_handler  . . . . . . .           8  Near Ptr 
array_t  . . . . . . . . . . . .           8  Near Ptr Near Ptr Byte
assume_segreg  . . . . . . . . .           4  DWord
asym_t . . . . . . . . . . . . .           8  Near Ptr asym
bool . . . . . . . . . . . . . .           4  DWord
char_t . . . . . . . . . . . . .           1  Byte
cpu_info . . . . . . . . . . . .           4  DWord
cvex_values  . . . . . . . . . .           4  DWord
cvoption_flags . . . . . . . . .           4  DWord
debug_t  . . . . . . . . . . . .           8  Near Ptr debug_info
dist_type  . . . . . . . . . . .           4  DWord
dlldesc_t  . . . . . . . . . . .           8  Near Ptr dll_desc
dsym_t . . . . . . . . . . . . .           8  Near Ptr dsym
errno_t  . . . . . . . . . . . .           4  DWord
file_extensions  . . . . . . . .           4  DWord
fpo  . . . . . . . . . . . . . .           4  DWord
group_t  . . . . . . . . . . . .           8  Near Ptr grp_info
int128_t . . . . . . . . . . . .          16  XmmWord
int16_t  . . . . . . . . . . . .           2  Word
int32_t  . . . . . . . . . . . .           4  DWord
int64_t  . . . . . . . . . . . .           8  QWord
int8_t . . . . . . . . . . . . .           1  Byte
int_16 . . . . . . . . . . . . .           2  Word
int_32 . . . . . . . . . . . . .           4  DWord
int_64 . . . . . . . . . . . . .           8  QWord
int_8  . . . . . . . . . . . . .           1  Byte
int_t  . . . . . . . . . . . . .           4  DWord
intptr_t . . . . . . . . . . . .           8  QWord
lang_type  . . . . . . . . . . .           4  DWord
line_output_flags  . . . . . . .           4  DWord
listmacro  . . . . . . . . . . .           4  DWord
long_t . . . . . . . . . . . . .           4  DWord
masm_cpu . . . . . . . . . . . .           4  DWord
model_type . . . . . . . . . . .           4  DWord
mparm_t  . . . . . . . . . . . .           8  Near Ptr mparm_list
offset_type  . . . . . . . . . .           4  DWord
oformat  . . . . . . . . . . . .           4  DWord
onexit_t . . . . . . . . . . . .           8  Near Ptr 
opt_names  . . . . . . . . . . .           4  DWord
opt_queues . . . . . . . . . . .           4  DWord
os_type  . . . . . . . . . . . .           4  DWord
proc_t . . . . . . . . . . . . .           8  Near Ptr proc_info
prologue_epilogue_mode . . . . .           4  DWord
pthreadlocinfo . . . . . . . . .           8  Near Ptr threadlocinfo
ptr? . . . . . . . . . . . . . .           8  Near Ptr 
ptr?__lc_time_data . . . . . . .           8  Near Ptr __lc_time_data
ptr?asm_tok  . . . . . . . . . .           8  Near Ptr asm_tok
ptr?asym . . . . . . . . . . . .           8  Near Ptr asym
ptr?byte . . . . . . . . . . . .           8  Near Ptr Byte
ptr?com_item . . . . . . . . . .           8  Near Ptr com_item
ptr?debug_info . . . . . . . . .           8  Near Ptr debug_info
ptr?dll_desc . . . . . . . . . .           8  Near Ptr dll_desc
ptr?dsym . . . . . . . . . . . .           8  Near Ptr dsym
ptr?fixup  . . . . . . . . . . .           8  Near Ptr fixup
ptr?flt_item . . . . . . . . . .           8  Near Ptr flt_item
ptr?format_options . . . . . . .           8  Near Ptr format_options
ptr?grp_info . . . . . . . . . .           8  Near Ptr grp_info
ptr?hll_item . . . . . . . . . .           8  Near Ptr hll_item
ptr?macro_info . . . . . . . . .           8  Near Ptr macro_info
ptr?mparm_list . . . . . . . . .           8  Near Ptr mparm_list
ptr?nsp_item . . . . . . . . . .           8  Near Ptr nsp_item
ptr?proc_info  . . . . . . . . .           8  Near Ptr proc_info
ptr?qditem . . . . . . . . . . .           8  Near Ptr qditem
ptr?qitem  . . . . . . . . . . .           8  Near Ptr qitem
ptr?sbyte  . . . . . . . . . . .           8  Near Ptr Byte
ptr?seg_item . . . . . . . . . .           8  Near Ptr seg_item
ptr?sfield . . . . . . . . . . .           8  Near Ptr sfield
ptr?src_item . . . . . . . . . .           8  Near Ptr src_item
ptr?srcline  . . . . . . . . . .           8  Near Ptr srcline
ptr?str_item . . . . . . . . . .           8  Near Ptr str_item
ptr?struct_info  . . . . . . . .           8  Near Ptr struct_info
ptr?threadlocinfo  . . . . . . .           8  Near Ptr threadlocinfo
ptr?threadmbcinfo  . . . . . . .           8  Near Ptr threadmbcinfo
ptr?word . . . . . . . . . . . .           8  Near Ptr Word
ptr_t  . . . . . . . . . . . . .           8  Near Ptr 
qdesc_t  . . . . . . . . . . . .           8  Near Ptr qdesc
qnode_t  . . . . . . . . . . . .           8  Near Ptr qnode
seg_order  . . . . . . . . . . .           4  DWord
seg_type . . . . . . . . . . . .           4  DWord
segitem_t  . . . . . . . . . . .           8  Near Ptr seg_item
segment_t  . . . . . . . . . . .           8  Near Ptr seg_info
segofssize . . . . . . . . . . .           4  DWord
sformat  . . . . . . . . . . . .           4  DWord
short_t  . . . . . . . . . . . .           2  Word
size_t . . . . . . . . . . . . .           8  QWord
srcitem_t  . . . . . . . . . . .           8  Near Ptr src_item
srcline_t  . . . . . . . . . . .           8  Near Ptr srcline
stdcall_decoration . . . . . . .           4  DWord
string_t . . . . . . . . . . . .           8  Near Ptr Byte
sym_state  . . . . . . . . . . .           4  DWord
token_t  . . . . . . . . . . . .           8  Near Ptr asm_tok
uchar_t  . . . . . . . . . . . .           1  Byte
uint128_t  . . . . . . . . . . .          16  XmmWord
uint16_t . . . . . . . . . . . .           2  Word
uint32_t . . . . . . . . . . . .           4  DWord
uint64_t . . . . . . . . . . . .           8  QWord
uint8_t  . . . . . . . . . . . .           1  Byte
uint_16  . . . . . . . . . . . .           2  Word
uint_32  . . . . . . . . . . . .           4  DWord
uint_64  . . . . . . . . . . . .           8  QWord
uint_8 . . . . . . . . . . . . .           1  Byte
uint_t . . . . . . . . . . . . .           4  DWord
uintptr_t  . . . . . . . . . . .           8  QWord
ulong_t  . . . . . . . . . . . .           4  DWord
ushort_t . . . . . . . . . . . .           2  Word
ustring_t  . . . . . . . . . . .           8  Near Ptr Byte
warray_t . . . . . . . . . . . .           8  Near Ptr Near Ptr Word
wchar_t  . . . . . . . . . . . .           2  Word
wctype_t . . . . . . . . . . . .           2  Word
win64_flag_values  . . . . . . .           4  DWord
wint_t . . . . . . . . . . . . .           2  Word
wstring_t  . . . . . . . . . . .           8  Near Ptr Word


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .        GROUP
.pdata . . . . . . . . . . . . .        64 Bit   000000D8 DWord   Private 'DATA'
.xdata . . . . . . . . . . . . .        64 Bit   000000AC QWord   Private 'DATA'
_DATA  . . . . . . . . . . . . .        64 Bit   00000101 Para    Public  'DATA'
_TEXT  . . . . . . . . . . . . .        64 Bit   00000532 Para    Public  'CODE'


Procedures, parameters and locals:

                N a m e                 Type     Value    Segment  Length

AddLinnumDataRef . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
AsmcKeywords . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
AssembleModule . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
CmdlineFini  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ConvertSectionName . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
DelayExpand  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ErrnoStr . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
FillDataBytes  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GetType  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
IS_SIGNED  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
NameSpace  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
NameSpaceDirective . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
OutputByte . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
OutputBytes  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ParseCmdline . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
PrintNote  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
QAddItem . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
QEnqueue . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
RetLineQueue . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SetCPU . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SetMasm510 . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymAddGlobal . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymAddLocal  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymAlloc . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymClearLocal  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymCreate  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymEnum  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymFind  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymFree  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymGetAll  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymGetCount  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymGetLocal  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymInit  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymLCreate . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymLookup  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymLookupLocal . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymMakeAllSymbolsPublic  . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymPassInit  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymSetCmpFunc  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymSetLocal  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
WriteError . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
___mb_cur_max_func . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
___mb_cur_max_l_func . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__doserrno . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__getmainargs  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__iob_func . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__sys_errlist  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__sys_nerr . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__wgetmainargs . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_abs64 . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_free  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_malloc  . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_msize . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_offset_malloc . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_offset_realloc  . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_offset_recalloc . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_realloc . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_recalloc  . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atodbl  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atodbl_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atof_l  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoflt  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoflt_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoi128 . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoi64  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoi64_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoi_l  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atol_l  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoldbl . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoldbl_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoll_l . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_beep  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_dosmaperr . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_dupenv_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ecvt  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ecvt_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_errno . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_exit  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fcvt  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fcvt_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fgetwchar . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_filbuf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fileno  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_filwbuf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_flsbuf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_flswbuf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_flushall  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fputchar  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fputwchar . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_freebuf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ftbuf . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fullpath  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_gcvt  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_gcvt_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_doserrno  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_errno . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_fmode . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_invalid_parameter_handler .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_pgmptr  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_purecall_handler  . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_wpgmptr . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_getbuf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_getst . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_getws . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_i64toa  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_i64toa_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_i64tow  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_i64tow_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_itoa  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_itoa_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_itow  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_itow_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ltoa  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ltoa_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ltow  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ltow_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_makepath  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_makepath_s  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbccpy_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mblen_l . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbspbrk . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbstowcs_s_l  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbstrlen  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbstrlen_l  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbstrnlen . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbstrnlen_l . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbtowc_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_memicmp . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_onexit  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_openfile  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_output  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_putenv  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_putenv_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_putws . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_recalloc  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_searchenv_s . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_abort_behavior  . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_doserrno  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_errno . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_error_mode  . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_fmode . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_invalid_parameter_handler .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_purecall_handler  . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_seterrormode  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_sleep . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_snwprintf . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_splitpath . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_splitpath_s . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_stbuf . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strdup  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_stricmp . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strlwr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strlwr_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strnicmp  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strnset . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strnset_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strrev  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strset  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strset_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtod_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtof_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoi64  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoi64_l  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtol_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtold . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtold_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoll_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoq  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoui64 . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoui64_l . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoul_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoull_l  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strupr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strupr_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_swab  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ui64toa . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ui64toa_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ui64tow . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ui64tow_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ultoa . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ultoa_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ultow . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ultow_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_vsnprintf . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_vsnwprintf  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsdup  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsicmp . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsicoll  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcslwr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcslwr_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsncoll  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsnicmp  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsnicoll . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsnset . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsnset_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsrev  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsset  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsset_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstod_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstof_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoi64  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoi64_l  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstol_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstold_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoll_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstombs_s_l  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoui64 . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoui64_l . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoul_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoull_l  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsupr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsupr_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wctomb_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wctomb_s_l  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wdupenv_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wfdopen . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wfopen  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wfreopen  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wfsopenproto  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wfullpath . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wgetenv . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wgetenv_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wmakepath_s . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_woutput . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wperror . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wpopen  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wputenv . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wputenv_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wremove . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wsearchenv_s  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wsplitpath  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wsplitpath_s  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wsystem . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtempnam  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtmpnam . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtof  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtof_l  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtoi  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtoi64  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtoi64_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtoi_l  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtol  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtol_l  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtoll . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtoll_l . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
abort  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
abs  . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
asmerr . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
assert_exit  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
atexit . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
atof . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
atoi . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
atol . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
atoll  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
bsearch  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
bsearch_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
calloc . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
close_files  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
define_name  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ecvt . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
exit . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fclose . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fcvt . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
feof . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fflush . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fgetc  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fgets  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fgetwc . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fgetws . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fopen  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fopen_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fprintf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fputc  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fputs  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fputwc . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fputws . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fread  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
free . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fseek  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ftell  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ftobufin . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fwprintf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fwrite . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fwscanf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
gcvt . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
getc . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
getenv . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
getenv_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
getwc  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
getwchar . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
is_valid_first_char  . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
is_valid_id_char . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
is_valid_id_first_char . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
is_valid_id_start  . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islabel  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islalnum . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islalpha . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islascii . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islcntrl . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
isldigit . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islgraph . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
isllower . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islprint . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islpunct . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islspace . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islupper . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islxdigit  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
itoa . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
labs . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ldiv . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
llabs  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
lldiv  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ltoa . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ltokstart  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
malloc . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
mblen  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
mbstowcs . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
mbstowcs_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
mbtowc . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memchr . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memcmp . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memcpy . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memcpy_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memmove  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memset . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memxchg  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
myltoa . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
onexit . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
perror . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
printf . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
putenv . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
puts . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
putwc  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
putwchar . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
qsort  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
qsort4 . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
qsort_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
rand . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
realloc  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
rewind . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
scanf  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
setargv  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
setbuf . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
setvbuf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
setwargv . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
sprintf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
srand  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strcat . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strcat_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strchr . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strcmp . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strcpy . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strcpy_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strlen . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strncat_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strncmp  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strncpy  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strncpy_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strrchr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strstr . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtod . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtof . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtok . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtok_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtol . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtold  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtoll  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtoqd  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtoul  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtoull . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
swab . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
swprintf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
swprintf_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
swscanf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
swscanf_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
system . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tgetenv  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tmemcmp  . . . . . . . . . . . .        P Near   00000268 _TEXT    *X Public   FASTCALL
  dst  . . . . . . . . . . . . .        Near              rsp + 0020
  src  . . . . . . . . . . . . .        Near              rsp + 0028
  size . . . . . . . . . . . . .        DWord             rsp + 0030
  .0 . . . . . . . . . . . . . .        L Near   00000282 _TEXT
tmemcpy  . . . . . . . . . . . .        P Near   00000062 _TEXT    *X Public   FASTCALL
  dst  . . . . . . . . . . . . .        Near              rsp + 0010
  src  . . . . . . . . . . . . .        Near              rsp + 0018
  z  . . . . . . . . . . . . . .        DWord             rsp + 0020
tmemicmp . . . . . . . . . . . .        P Near   00000289 _TEXT    *X Public   FASTCALL
  dst  . . . . . . . . . . . . .        Near              rsp + 0010
  src  . . . . . . . . . . . . .        Near              rsp + 0018
  size . . . . . . . . . . . . .        DWord             rsp + 0020
  .0 . . . . . . . . . . . . . .        L Near   0000028D _TEXT
  .1 . . . . . . . . . . . . . .        L Near   000002B5 _TEXT
tmemmove . . . . . . . . . . . .        P Near   00000076 _TEXT    *X Public   FASTCALL
  dst  . . . . . . . . . . . . .        Near              rsp + 0020
  src  . . . . . . . . . . . . .        Near              rsp + 0028
  z  . . . . . . . . . . . . . .        DWord             rsp + 0030
  .0 . . . . . . . . . . . . . .        L Near   00000091 _TEXT
  .1 . . . . . . . . . . . . . .        L Near   0000009F _TEXT
tmemset  . . . . . . . . . . . .        P Near   000000A6 _TEXT    *X Public   FASTCALL
  dst  . . . . . . . . . . . . .        Near              rsp + 0010
  char . . . . . . . . . . . . .        DWord             rsp + 0018
  count  . . . . . . . . . . . .        DWord             rsp + 0020
tprintf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tqsort . . . . . . . . . . . . .        P Near   0000035F _TEXT    *X Public   FASTCALL
  p  . . . . . . . . . . . . . .        Near              rbp + 0048
  n  . . . . . . . . . . . . . .        DWord             rbp + 0050
  w  . . . . . . . . . . . . . .        DWord             rbp + 0058
  compare  . . . . . . . . . . .        Near              rbp + 0060
  @C0011 . . . . . . . . . . . .        L Near   0000044F _TEXT
  @C0010 . . . . . . . . . . . .        L Near   00000433 _TEXT
  @C0013 . . . . . . . . . . . .        L Near   00000465 _TEXT
  @C0012 . . . . . . . . . . . .        L Near   00000465 _TEXT
  @C0015 . . . . . . . . . . . .        L Near   000004AE _TEXT
  @C0014 . . . . . . . . . . . .        L Near   0000047D _TEXT
  @C0017 . . . . . . . . . . . .        L Near   000004AC _TEXT
  @C0016 . . . . . . . . . . . .        L Near   0000048E _TEXT
  @C0019 . . . . . . . . . . . .        L Near   000004C8 _TEXT
  @C0018 . . . . . . . . . . . .        L Near   000004B1 _TEXT
  @C000A . . . . . . . . . . . .        L Near   000003BA _TEXT
  @C000C . . . . . . . . . . . .        L Near   000003D9 _TEXT
  @C000B . . . . . . . . . . . .        L Near   000003EF _TEXT
  @C000E . . . . . . . . . . . .        L Near   00000406 _TEXT
  @C000D . . . . . . . . . . . .        L Near   0000041C _TEXT
  @C000F . . . . . . . . . . . .        L Near   00000449 _TEXT
  @C0020 . . . . . . . . . . . .        L Near   00000525 _TEXT
  @C0009 . . . . . . . . . . . .        L Near   000003A2 _TEXT
  @C0008 . . . . . . . . . . . .        L Near   00000525 _TEXT
  @C001A . . . . . . . . . . . .        L Near   000004FC _TEXT
  @C001C . . . . . . . . . . . .        L Near   000004FA _TEXT
  @C001B . . . . . . . . . . . .        L Near   000004ED _TEXT
  @C001E . . . . . . . . . . . .        L Near   00000509 _TEXT
  @C001D . . . . . . . . . . . .        L Near   00000516 _TEXT
  @C001F . . . . . . . . . . . .        L Near   00000516 _TEXT
tsprintf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tstrcat  . . . . . . . . . . . .        P Near   00000215 _TEXT    *X Public   FASTCALL
  dst  . . . . . . . . . . . . .        Near              rsp + 0010
  src  . . . . . . . . . . . . .        Near              rsp + 0018
  .0 . . . . . . . . . . . . . .        L Near   0000021E _TEXT
  .1 . . . . . . . . . . . . . .        L Near   00000228 _TEXT
  .2 . . . . . . . . . . . . . .        L Near   0000023A _TEXT
tstrchr  . . . . . . . . . . . .        P Near   000000CE _TEXT    *X Public   FASTCALL
  string . . . . . . . . . . . .        Near              rsp + 0010
  char . . . . . . . . . . . . .        DWord             rsp + 0018
  .0 . . . . . . . . . . . . . .        L Near   000000D4 _TEXT
  .1 . . . . . . . . . . . . . .        L Near   000000E6 _TEXT
tstrcmp  . . . . . . . . . . . .        P Near   00000244 _TEXT    *X Public   FASTCALL
  a  . . . . . . . . . . . . . .        Near              rsp + 0010
  b  . . . . . . . . . . . . . .        Near              rsp + 0018
  .0 . . . . . . . . . . . . . .        L Near   0000024D _TEXT
  .1 . . . . . . . . . . . . . .        L Near   00000263 _TEXT
tstrcpy  . . . . . . . . . . . .        P Near   00000108 _TEXT    *X Public   FASTCALL
  dst  . . . . . . . . . . . . .        Near              rsp + 0010
  src  . . . . . . . . . . . . .        Near              rsp + 0018
  .0 . . . . . . . . . . . . . .        L Near   0000018D _TEXT
  .1 . . . . . . . . . . . . . .        L Near   000001B1 _TEXT
  .2 . . . . . . . . . . . . . .        L Near   000001DA _TEXT
tstricmp . . . . . . . . . . . .        P Near   000002BD _TEXT    *X Public   FASTCALL
  a  . . . . . . . . . . . . . .        Near              rsp + 0010
  b  . . . . . . . . . . . . . .        Near              rsp + 0018
  .0 . . . . . . . . . . . . . .        L Near   000002C9 _TEXT
  .1 . . . . . . . . . . . . . .        L Near   000002EE _TEXT
tstrlen  . . . . . . . . . . . .        P Near   000000B9 _TEXT    *X Public   FASTCALL
  string . . . . . . . . . . . .        Near              rsp + 0010
tstrncpy . . . . . . . . . . . .        P Near   000001E2 _TEXT    *X Public   FASTCALL
  dst  . . . . . . . . . . . . .        Near              rsp + 0010
  src  . . . . . . . . . . . . .        Near              rsp + 0018
  count  . . . . . . . . . . . .        DWord             rsp + 0020
  .0 . . . . . . . . . . . . . .        L Near   000001F2 _TEXT
  .1 . . . . . . . . . . . . . .        L Near   00000208 _TEXT
  .2 . . . . . . . . . . . . . .        L Near   0000020A _TEXT
tstrrchr . . . . . . . . . . . .        P Near   000000EB _TEXT    *X Public   FASTCALL
  string . . . . . . . . . . . .        Near              rsp + 0010
  char . . . . . . . . . . . . .        DWord             rsp + 0018
  .0 . . . . . . . . . . . . . .        L Near   000000F1 _TEXT
  .1 . . . . . . . . . . . . . .        L Near   00000103 _TEXT
tstrstart  . . . . . . . . . . .        P Near   00000020 _TEXT    *X Public   WATCALL
  string . . . . . . . . . . . .        Near              rsp + 256D3A8
  .0 . . . . . . . . . . . . . .        L Near   0000002E _TEXT
  .1 . . . . . . . . . . . . . .        L Near   0000003C _TEXT
tstrstartr . . . . . . . . . . .        P Near   00000041 _TEXT    *X Public   WATCALL
  string . . . . . . . . . . . .        Near              rsp + 256D4C8
  .0 . . . . . . . . . . . . . .        L Near   0000004F _TEXT
  .1 . . . . . . . . . . . . . .        L Near   0000005D _TEXT
tstrstr  . . . . . . . . . . . .        P Near   000002F6 _TEXT    *X Public   FASTCALL
  dst  . . . . . . . . . . . . .        Near              rsp + 0020
  src  . . . . . . . . . . . . .        Near              rsp + 0028
  @C0001 . . . . . . . . . . . .        L Near   0000035B _TEXT
  @C0003 . . . . . . . . . . . .        L Near   00000334 _TEXT
  @C0002 . . . . . . . . . . . .        L Near   0000035B _TEXT
  @C0005 . . . . . . . . . . . .        L Near   00000357 _TEXT
  @C0004 . . . . . . . . . . . .        L Near   0000035B _TEXT
  @C0007 . . . . . . . . . . . .        L Near   0000035B _TEXT
  @C0006 . . . . . . . . . . . .        L Near   00000349 _TEXT
tstrupr  . . . . . . . . . . . .        P Near   00000000 _TEXT    *X Public   FASTCALL
  string . . . . . . . . . . . .        Near              rsp + 0010
  .0 . . . . . . . . . . . . . .        L Near   00000005 _TEXT
  .1 . . . . . . . . . . . . . .        L Near   0000001A _TEXT
tvfprintf  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tvsprintf  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ultoa  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ungetc . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ungetwc  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
vfprintf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
vfwprintf  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
vsprintf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
vswprintf  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
vwprintf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscat . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscat_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcschr . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscmp . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscoll  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscpy . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscpy_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscspn  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcslen . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsncat  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsncat_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsncmp  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsncpy  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsncpy_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsnlen  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcspbrk  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsrchr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsspn . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsstr . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstod . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstof . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstok . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstok_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstol . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstold  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstoll  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstombs_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstoul  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstoull . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsxfrm  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wctomb . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wctomb_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wprintf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
write_logo . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
write_options  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
write_usage  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wscanf . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL


Symbols:

                N a m e                 Type       Value     Attr

$xdatasym  . . . . . . . . . . .        L Near             0h .xdata FASTCALL
@ProcStatus  . . . . . . . . . .        Number             0h 
@StackBase . . . . . . . . . . .        Number             0h 
ASM  . . . . . . . . . . . . . .        Number             0h 
ASMC_MAJOR_VER . . . . . . . . .        Number             2h 
ASMC_MINOR_VER . . . . . . . . .        Number            21h 
ASMC_SUBMINOR_VER  . . . . . . .        Number            1Bh 
ASMC_VERSION . . . . . . . . . .        Number            E9h 
ASMC_VERSSTR . . . . . . . . . .        Text   "2.33.27"
ASSUME_CS  . . . . . . . . . . .        Number             1h 
ASSUME_DS  . . . . . . . . . . .        Number             3h 
ASSUME_ES  . . . . . . . . . . .        Number             0h 
ASSUME_FS  . . . . . . . . . . .        Number             4h 
ASSUME_GS  . . . . . . . . . . .        Number             5h 
ASSUME_NOTHING . . . . . . . . .        Number      FFFFFFFEh 
ASSUME_SS  . . . . . . . . . . .        Number             2h 
BLOCK_ACTIVE . . . . . . . . . .        Number             0h 
BLOCK_DONE . . . . . . . . . . .        Number             2h 
BLOCK_INACTIVE . . . . . . . . .        Number             1h 
CHAR_BIT . . . . . . . . . . . .        Number             8h 
CHAR_MAX . . . . . . . . . . . .        Number            7Fh 
CHAR_MIN . . . . . . . . . . . .        Number     -00000080h 
CHEXPREFIX . . . . . . . . . . .        Number             0h 
CSF_GRPCHK . . . . . . . . . . .        Number             1h 
CSI_BSS  . . . . . . . . . . . .        Number             3h 
CSI_CONST  . . . . . . . . . . .        Number             2h 
CSI_DATA . . . . . . . . . . . .        Number             1h 
CSI_TEXT . . . . . . . . . . . .        Number             0h 
CVEX_MAX . . . . . . . . . . . .        Number             3h 
CVEX_MIN . . . . . . . . . . . .        Number             0h 
CVEX_NORMAL  . . . . . . . . . .        Number             2h 
CVEX_REDUCED . . . . . . . . . .        Number             1h 
CVO_STATICTLS  . . . . . . . . .        Number             1h 
CurrFName  . . . . . . . . . . .        Text   ModuleInfo.curr_fname
CurrFile . . . . . . . . . . . .        Text   ModuleInfo.curr_file
CurrSeg  . . . . . . . . . . . .        Text   ModuleInfo.currseg
CurrSource . . . . . . . . . . .        Text   ModuleInfo.currsource
CurrWordSize . . . . . . . . . .        Text   ModuleInfo.wordsize
DefaultDir . . . . . . . . . . .        Near               0h *External FASTCALL
EMPTY  . . . . . . . . . . . . .        Number     -00000002h 
EOF  . . . . . . . . . . . . . .        Number     -00000001h 
ERR  . . . . . . . . . . . . . .        Number             3h 
ERROR  . . . . . . . . . . . . .        Number     -00000001h 
FALSE  . . . . . . . . . . . . .        Number             0h 
FCT_ELF64  . . . . . . . . . . .        Number             3h 
FCT_MSC  . . . . . . . . . . . .        Number             0h 
FCT_VEC32  . . . . . . . . . . .        Number             4h 
FCT_VEC64  . . . . . . . . . . .        Number             5h 
FCT_WATCOMC  . . . . . . . . . .        Number             1h 
FCT_WIN64  . . . . . . . . . . .        Number             2h 
FILENAME_MAX . . . . . . . . . .        Number           104h 
FPO_EMULATION  . . . . . . . . .        Number             1h 
FPO_NO_EMULATION . . . . . . . .        Number             0h 
I32_SPEC . . . . . . . . . . . .        Text   ""
I64_SPEC . . . . . . . . . . . .        Text   "I64"
INT_MAX  . . . . . . . . . . . .        Number      7FFFFFFFh 
INT_MIN  . . . . . . . . . . . .        Number     -80000000h 
LANG_BASIC . . . . . . . . . . .        Number             6h 
LANG_C . . . . . . . . . . . . .        Number             1h 
LANG_FASTCALL  . . . . . . . . .        Number             7h 
LANG_FORTRAN . . . . . . . . . .        Number             5h 
LANG_NONE  . . . . . . . . . . .        Number             0h 
LANG_PASCAL  . . . . . . . . . .        Number             4h 
LANG_STDCALL . . . . . . . . . .        Number             3h 
LANG_SYSCALL . . . . . . . . . .        Number             2h 
LANG_VECTORCALL  . . . . . . . .        Number             8h 
LANG_WATCALL . . . . . . . . . .        Number             9h 
LLONG_MAX  . . . . . . . . . . .        Number      7FFFFFFFFFFFFFFFh 
LLONG_MIN  . . . . . . . . . . .        Number      8000000000000000h 
LM_LISTMACRO . . . . . . . . . .        Number             1h 
LM_LISTMACROALL  . . . . . . . .        Number             2h 
LM_NOLISTMACRO . . . . . . . . .        Number             0h 
LNAME_NULL . . . . . . . . . . .        Number             0h 
LOF_LISTED . . . . . . . . . . .        Number             1h 
LOF_SKIPPOS  . . . . . . . . . .        Number             2h 
LONG_MAX . . . . . . . . . . . .        Number      7FFFFFFFh 
LONG_MIN . . . . . . . . . . . .        Number     -80000000h 
LST  . . . . . . . . . . . . . .        Number             2h 
LastCodeBufSize  . . . . . . . .        DWord              0h *External FASTCALL
LinnumQueue  . . . . . . . . . .        qdesc              0h *External FASTCALL
MAX_ID_LEN . . . . . . . . . . .        Number            F7h 
MAX_IF_NESTING . . . . . . . . .        Number            14h 
MAX_LINE_LEN . . . . . . . . . .        Number           800h 
MAX_LNAME  . . . . . . . . . . .        Number            FFh 
MAX_MACRO_NESTING  . . . . . . .        Number            64h 
MAX_SEGALIGNMENT . . . . . . . .        Number            FFh 
MAX_SEGMENT_ALIGN  . . . . . . .        Number          1000h 
MAX_SEG_NESTING  . . . . . . . .        Number            14h 
MAX_STRING_LEN . . . . . . . . .        Number           7E0h 
MAX_STRUCT_ALIGN . . . . . . . .        Number            20h 
MAX_STRUCT_NESTING . . . . . . .        Number            20h 
MAX_TOKEN  . . . . . . . . . . .        Number           200h 
MB_CUR_MAX . . . . . . . . . . .        Text   ___mb_cur_max_func()
MB_LEN_MAX . . . . . . . . . . .        Number             2h 
MODEL_COMPACT  . . . . . . . . .        Number             3h 
MODEL_FLAT . . . . . . . . . . .        Number             7h 
MODEL_HUGE . . . . . . . . . . .        Number             6h 
MODEL_LARGE  . . . . . . . . . .        Number             5h 
MODEL_MEDIUM . . . . . . . . . .        Number             4h 
MODEL_NONE . . . . . . . . . . .        Number             0h 
MODEL_SMALL  . . . . . . . . . .        Number             2h 
MODEL_TINY . . . . . . . . . . .        Number             1h 
MT_ABS . . . . . . . . . . . . .        Number            C2h 
MT_ADDRESS . . . . . . . . . . .        Number            80h 
MT_BITS  . . . . . . . . . . . .        Number            C1h 
MT_BYTE  . . . . . . . . . . . .        Number             0h 
MT_DWORD . . . . . . . . . . . .        Number             3h 
MT_EMPTY . . . . . . . . . . . .        Number            C0h 
MT_FAR . . . . . . . . . . . . .        Number            82h 
MT_FLOAT . . . . . . . . . . . .        Number            20h 
MT_FWORD . . . . . . . . . . . .        Number             5h 
MT_NEAR  . . . . . . . . . . . .        Number            81h 
MT_OWORD . . . . . . . . . . . .        Number             Fh 
MT_PROC  . . . . . . . . . . . .        Number            80h 
MT_PTR . . . . . . . . . . . . .        Number            C3h 
MT_QWORD . . . . . . . . . . . .        Number             7h 
MT_REAL10  . . . . . . . . . . .        Number            29h 
MT_REAL16  . . . . . . . . . . .        Number            2Fh 
MT_REAL2 . . . . . . . . . . . .        Number            21h 
MT_REAL4 . . . . . . . . . . . .        Number            23h 
MT_REAL8 . . . . . . . . . . . .        Number            27h 
MT_SBYTE . . . . . . . . . . . .        Number            40h 
MT_SDWORD  . . . . . . . . . . .        Number            43h 
MT_SIGNED  . . . . . . . . . . .        Number            40h 
MT_SIZE_MASK . . . . . . . . . .        Number            1Fh 
MT_SPECIAL . . . . . . . . . . .        Number            80h 
MT_SPECIAL_MASK  . . . . . . . .        Number            C0h 
MT_SQWORD  . . . . . . . . . . .        Number            47h 
MT_SWORD . . . . . . . . . . . .        Number            41h 
MT_TBYTE . . . . . . . . . . . .        Number             9h 
MT_TYPE  . . . . . . . . . . . .        Number            C4h 
MT_WORD  . . . . . . . . . . . .        Number             1h 
MT_YMMWORD . . . . . . . . . . .        Number            1Fh 
MT_YWORD . . . . . . . . . . . .        Number            1Fh 
MT_ZMMWORD . . . . . . . . . . .        Number            3Fh 
MT_ZWORD . . . . . . . . . . . .        Number            3Fh 
M_186  . . . . . . . . . . . . .        Number             2h 
M_286  . . . . . . . . . . . . .        Number             4h 
M_287  . . . . . . . . . . . . .        Number           400h 
M_386  . . . . . . . . . . . . .        Number             8h 
M_387  . . . . . . . . . . . . .        Number           800h 
M_486  . . . . . . . . . . . . .        Number            10h 
M_586  . . . . . . . . . . . . .        Number            20h 
M_686  . . . . . . . . . . . . .        Number            40h 
M_8086 . . . . . . . . . . . . .        Number             1h 
M_8087 . . . . . . . . . . . . .        Number           100h 
M_CPUMSK . . . . . . . . . . . .        Number            7Fh 
M_ISFUNC . . . . . . . . . . . .        Number             2h 
M_ISVARARG . . . . . . . . . . .        Number             1h 
M_LABEL  . . . . . . . . . . . .        Number             4h 
M_MULTILINE  . . . . . . . . . .        Number             8h 
M_PROT . . . . . . . . . . . . .        Number            80h 
M_PURGED . . . . . . . . . . . .        Number            10h 
MacroLevel . . . . . . . . . . .        DWord              0h *External FASTCALL
ModelToken . . . . . . . . . . .        Near               0h *External FASTCALL
ModuleInfo . . . . . . . . . . .        module_info         0h *External FASTCALL
NOTE_INCLUDED_BY . . . . . . . .        Number             0h 
NOTE_ITERATION_MACRO_CALLED_FROM         Number             2h 
NOTE_MACRO_CALLED_FROM . . . . .        Number             1h 
NOTE_MAIN_LINE_CODE  . . . . . .        Number             3h 
NOT_ERROR  . . . . . . . . . . .        Number             0h 
NO_OPPRFX  . . . . . . . . . . .        Number          FD00h 
NTDDI_VERSION  . . . . . . . . .        Number       6010000h 
NTDDI_WIN2003  . . . . . . . . .        Number       5000000h 
NULL . . . . . . . . . . . . . .        Number             0h 
NULLC  . . . . . . . . . . . . .        Number             0h 
NUM_FILE_TYPES . . . . . . . . .        Number             4h 
OBJ  . . . . . . . . . . . . . .        Number             1h 
OFORMAT_BIN  . . . . . . . . . .        Number             0h 
OFORMAT_COFF . . . . . . . . . .        Number             2h 
OFORMAT_ELF  . . . . . . . . . .        Number             3h 
OFORMAT_OMF  . . . . . . . . . .        Number             1h 
OLDKEYWORDS  . . . . . . . . . .        Number             0h 
OPSYS_DOS  . . . . . . . . . . .        Number             0h 
OPSYS_OS2  . . . . . . . . . . .        Number             1h 
OPTN_ASM_FN  . . . . . . . . . .        Number             0h 
OPTN_CODE_CLASS  . . . . . . . .        Number             8h 
OPTN_DATA_SEG  . . . . . . . . .        Number             7h 
OPTN_ERR_FN  . . . . . . . . . .        Number             3h 
OPTN_LAST  . . . . . . . . . . .        Number             9h 
OPTN_LNKDEF_FN . . . . . . . . .        Number             4h 
OPTN_LST_FN  . . . . . . . . . .        Number             2h 
OPTN_MODULE_NAME . . . . . . . .        Number             5h 
OPTN_OBJ_FN  . . . . . . . . . .        Number             1h 
OPTN_TEXT_SEG  . . . . . . . . .        Number             6h 
OPTQ_FINCLUDE  . . . . . . . . .        Number             0h 
OPTQ_INCPATH . . . . . . . . . .        Number             2h 
OPTQ_LAST  . . . . . . . . . . .        Number             3h 
OPTQ_MACRO . . . . . . . . . . .        Number             1h 
OPT_ASSERT . . . . . . . . . . .        Number            40h 
OPT_CSTACK . . . . . . . . . . .        Number             1h 
OPT_LSTRING  . . . . . . . . . .        Number             4h 
OPT_NOTABLE  . . . . . . . . . .        Number            10h 
OPT_PASCAL . . . . . . . . . . .        Number             8h 
OPT_PUSHF  . . . . . . . . . . .        Number            80h 
OPT_REGAX  . . . . . . . . . . .        Number            20h 
OPT_WSTRING  . . . . . . . . . .        Number             2h 
OT_FLAT  . . . . . . . . . . . .        Number             1h 
OT_GROUP . . . . . . . . . . . .        Number             0h 
OT_SEGMENT . . . . . . . . . . .        Number             2h 
Options  . . . . . . . . . . . .        global_options         0h *External FASTCALL
PASS_1 . . . . . . . . . . . . .        Number             0h 
PASS_2 . . . . . . . . . . . . .        Number             1h 
PEM_DEFAULT  . . . . . . . . . .        Number             0h 
PEM_MACRO  . . . . . . . . . . .        Number             1h 
PEM_NONE . . . . . . . . . . . .        Number             2h 
PROC_FORCEFRAME  . . . . . . . .        Number             8h 
PROC_FPO . . . . . . . . . . . .        Number            80h 
PROC_HAS_VARARG  . . . . . . . .        Number             1h 
PROC_ISEXPORT  . . . . . . . . .        Number             4h 
PROC_ISFRAME . . . . . . . . . .        Number            40h 
PROC_LOADDS  . . . . . . . . . .        Number            10h 
PROC_PE_TYPE . . . . . . . . . .        Number             2h 
PROC_STACKPARAM  . . . . . . . .        Number            20h 
PSAPI_VERSION  . . . . . . . . .        Number             0h 
P_186  . . . . . . . . . . . . .        Number            10h 
P_286  . . . . . . . . . . . . .        Number            20h 
P_286p . . . . . . . . . . . . .        Number            28h 
P_287  . . . . . . . . . . . . .        Number             3h 
P_386  . . . . . . . . . . . . .        Number            30h 
P_386p . . . . . . . . . . . . .        Number            38h 
P_387  . . . . . . . . . . . . .        Number             4h 
P_486  . . . . . . . . . . . . .        Number            40h 
P_486p . . . . . . . . . . . . .        Number            48h 
P_586  . . . . . . . . . . . . .        Number            50h 
P_586p . . . . . . . . . . . . .        Number            58h 
P_64 . . . . . . . . . . . . . .        Number            70h 
P_64p  . . . . . . . . . . . . .        Number            78h 
P_686  . . . . . . . . . . . . .        Number            60h 
P_686p . . . . . . . . . . . . .        Number            68h 
P_86 . . . . . . . . . . . . . .        Number             0h 
P_87 . . . . . . . . . . . . . .        Number             2h 
P_AVX  . . . . . . . . . . . . .        Number          8000h 
P_CPU_MASK . . . . . . . . . . .        Number            F0h 
P_EXT_ALL  . . . . . . . . . . .        Number          FF00h 
P_EXT_MASK . . . . . . . . . . .        Number          FF00h 
P_FPU_MASK . . . . . . . . . . .        Number             7h 
P_K3D  . . . . . . . . . . . . .        Number           200h 
P_MMX  . . . . . . . . . . . . .        Number           100h 
P_NO87 . . . . . . . . . . . . .        Number             1h 
P_PM . . . . . . . . . . . . . .        Number             8h 
P_SSE1 . . . . . . . . . . . . .        Number           400h 
P_SSE2 . . . . . . . . . . . . .        Number           800h 
P_SSE3 . . . . . . . . . . . . .        Number          1000h 
P_SSE4 . . . . . . . . . . . . .        Number          4000h 
P_SSEALL . . . . . . . . . . . .        Number          FC00h 
P_SSSE3  . . . . . . . . . . . .        Number          2000h 
Parse_Pass . . . . . . . . . . .        DWord              0h *External FASTCALL
RAND_MAX . . . . . . . . . . . .        Number          7FFFh 
SCHAR_MAX  . . . . . . . . . . .        Number            7Fh 
SCHAR_MIN  . . . . . . . . . . .        Number     -00000080h 
SEEK_CUR . . . . . . . . . . . .        Number             1h 
SEEK_END . . . . . . . . . . . .        Number             2h 
SEEK_SET . . . . . . . . . . . .        Number             0h 
SEGORDER_ALPHA . . . . . . . . .        Number             2h 
SEGORDER_DOSSEG  . . . . . . . .        Number             1h 
SEGORDER_SEQ . . . . . . . . . .        Number             0h 
SEGTYPE_ABS  . . . . . . . . . .        Number             5h 
SEGTYPE_BSS  . . . . . . . . . .        Number             3h 
SEGTYPE_CDATA  . . . . . . . . .        Number             7h 
SEGTYPE_CODE . . . . . . . . . .        Number             1h 
SEGTYPE_DATA . . . . . . . . . .        Number             2h 
SEGTYPE_ERROR  . . . . . . . . .        Number             Ah 
SEGTYPE_HDR  . . . . . . . . . .        Number             6h 
SEGTYPE_RELOC  . . . . . . . . .        Number             8h 
SEGTYPE_RSRC . . . . . . . . . .        Number             9h 
SEGTYPE_STACK  . . . . . . . . .        Number             4h 
SEGTYPE_UNDEF  . . . . . . . . .        Number             0h 
SFORMAT_64BIT  . . . . . . . . .        Number             3h 
SFORMAT_MZ . . . . . . . . . . .        Number             1h 
SFORMAT_NONE . . . . . . . . . .        Number             0h 
SFORMAT_PE . . . . . . . . . . .        Number             2h 
SHRT_MAX . . . . . . . . . . . .        Number          7FFFh 
SHRT_MIN . . . . . . . . . . . .        Number     -00008000h 
SIT_FILE . . . . . . . . . . . .        Number             0h 
SIT_MACRO  . . . . . . . . . . .        Number             1h 
SIZE_CODEPTR . . . . . . . . . .        Number            70h 
SIZE_DATAPTR . . . . . . . . . .        Number            68h 
SIZE_MAX . . . . . . . . . . . .        Number     -00000001h 
SI_ISINLINE  . . . . . . . . . .        Number             1h 
SI_ISOPEN  . . . . . . . . . . .        Number             2h 
SI_ORGINSIDE . . . . . . . . . .        Number             4h 
STACK_FAR  . . . . . . . . . . .        Number             1h 
STACK_NEAR . . . . . . . . . . .        Number             0h 
STDCALL_FULL . . . . . . . . . .        Number             0h 
STDCALL_HALF . . . . . . . . . .        Number             2h 
STDCALL_NONE . . . . . . . . . .        Number             1h 
STRING_EXPANDED  . . . . . . . .        Number             1h 
SYM_ALIAS  . . . . . . . . . . .        Number             8h 
SYM_CLASS_LNAME  . . . . . . . .        Number             Bh 
SYM_EXTERNAL . . . . . . . . . .        Number             2h 
SYM_GRP  . . . . . . . . . . . .        Number             4h 
SYM_INTERNAL . . . . . . . . . .        Number             1h 
SYM_MACRO  . . . . . . . . . . .        Number             9h 
SYM_SEG  . . . . . . . . . . . .        Number             3h 
SYM_STACK  . . . . . . . . . . .        Number             5h 
SYM_STRUCT_FIELD . . . . . . . .        Number             6h 
SYM_TMACRO . . . . . . . . . . .        Number             Ah 
SYM_TYPE . . . . . . . . . . . .        Number             7h 
SYM_UNDEFINED  . . . . . . . . .        Number             0h 
S_CLASS  . . . . . . . . . . . .        Number             1h 
S_FWDREF . . . . . . . . . . . .        Number            20h 
S_IAT_USED . . . . . . . . . . .        Number             8h 
S_INCLUDED . . . . . . . . . . .        Number            40h 
S_ISARRAY  . . . . . . . . . . .        Number             2h 
S_ISCOM  . . . . . . . . . . . .        Number             1h 
S_ISDATA . . . . . . . . . . . .        Number             4h 
S_ISDEFINED  . . . . . . . . . .        Number             2h 
S_ISEQUATE . . . . . . . . . . .        Number            10h 
S_ISINLINE . . . . . . . . . . .        Number            10h 
S_ISPROC . . . . . . . . . . . .        Number             8h 
S_ISPUBLIC . . . . . . . . . . .        Number            80h 
S_ISSAVED  . . . . . . . . . . .        Number            10h 
S_ISSTATIC . . . . . . . . . . .        Number            20h 
S_ISVARARG . . . . . . . . . . .        Number             4h 
S_ISVECTOR . . . . . . . . . . .        Number             8h 
S_ISVTABLE . . . . . . . . . . .        Number             4h 
S_LIST . . . . . . . . . . . . .        Number             1h 
S_METHOD . . . . . . . . . . . .        Number            80h 
S_OPERATOR . . . . . . . . . . .        Number            80h 
S_PREDEFINED . . . . . . . . . .        Number            20h 
S_SCOPED . . . . . . . . . . . .        Number             4h 
S_USED . . . . . . . . . . . . .        Number             1h 
S_VARIABLE . . . . . . . . . . .        Number            40h 
S_VMACRO . . . . . . . . . . . .        Number             8h 
S_VPARRAY  . . . . . . . . . . .        Number            40h 
S_VTABLE . . . . . . . . . . . .        Number             2h 
S_WEAK . . . . . . . . . . . . .        Number             2h 
StringBufferEnd  . . . . . . . .        Text   ModuleInfo.stringbufferend
SymCmpFunc . . . . . . . . . . .        Near               0h *External FASTCALL
TRUE . . . . . . . . . . . . . .        Number             1h 
TYPE_NONE  . . . . . . . . . . .        Number             0h 
TYPE_RECORD  . . . . . . . . . .        Number             4h 
TYPE_STRUCT  . . . . . . . . . .        Number             1h 
TYPE_TYPEDEF . . . . . . . . . .        Number             3h 
TYPE_UNION . . . . . . . . . . .        Number             2h 
T_BAD_NUM  . . . . . . . . . . .        Number             Ch 
T_BINARY_OPERATOR  . . . . . . .        Number             5h 
T_CL_BRACKET . . . . . . . . . .        Number            29h 
T_CL_SQ_BRACKET  . . . . . . . .        Number            5Dh 
T_COLON  . . . . . . . . . . . .        Number            3Ah 
T_COMMA  . . . . . . . . . . . .        Number            2Ch 
T_DBL_COLON  . . . . . . . . . .        Number             Dh 
T_DIRECTIVE  . . . . . . . . . .        Number             3h 
T_DOT  . . . . . . . . . . . . .        Number            2Eh 
T_EVEX_OPT . . . . . . . . . . .        Number            10h 
T_EXPR . . . . . . . . . . . . .        Number            40h 
T_FINAL  . . . . . . . . . . . .        Number             0h 
T_FLOAT  . . . . . . . . . . . .        Number             Bh 
T_HLL_DBLCOLON . . . . . . . . .        Number            20h 
T_HLL_DELAY  . . . . . . . . . .        Number             1h 
T_HLL_DELAYED  . . . . . . . . .        Number             8h 
T_HLL_MACRO  . . . . . . . . . .        Number             2h 
T_HLL_PROC . . . . . . . . . . .        Number             4h 
T_ID . . . . . . . . . . . . . .        Number             8h 
T_INSTRUCTION  . . . . . . . . .        Number             1h 
T_NUM  . . . . . . . . . . . . .        Number             Ah 
T_OP_BRACKET . . . . . . . . . .        Number            28h 
T_OP_SQ_BRACKET  . . . . . . . .        Number            5Bh 
T_PERCENT  . . . . . . . . . . .        Number            25h 
T_QUESTION_MARK  . . . . . . . .        Number            3Fh 
T_REG  . . . . . . . . . . . . .        Number             2h 
T_RES_ID . . . . . . . . . . . .        Number             7h 
T_STRING . . . . . . . . . . . .        Number             9h 
T_STYPE  . . . . . . . . . . . .        Number             6h 
T_UNARY_OPERATOR . . . . . . . .        Number             4h 
Token_Count  . . . . . . . . . .        Text   ModuleInfo.token_count
UCHAR_MAX  . . . . . . . . . . .        Number            FFh 
UINT_MAX . . . . . . . . . . . .        Number      FFFFFFFFh 
ULLONG_MAX . . . . . . . . . . .        Number     -00000001h 
ULONG_MAX  . . . . . . . . . . .        Number      FFFFFFFFh 
USE16  . . . . . . . . . . . . .        Number             0h 
USE32  . . . . . . . . . . . . .        Number             1h 
USE64  . . . . . . . . . . . . .        Number             2h 
USE_COMALLOC . . . . . . . . . .        Number             0h 
USE_EMPTY  . . . . . . . . . . .        Number            FEh 
USE_INDIRECTION  . . . . . . . .        Number             0h 
USHRT_MAX  . . . . . . . . . . .        Number          FFFFh 
W64F_ALL . . . . . . . . . . . .        Number             7h 
W64F_AUTOSTACKSP . . . . . . . .        Number             2h 
W64F_SAVEREGPARAMS . . . . . . .        Number             1h 
W64F_STACKALIGN16  . . . . . . .        Number             4h 
WINAPI . . . . . . . . . . . . .        Text   
WINVER . . . . . . . . . . . . .        Number           601h 
_CALLBACK_DEFINED  . . . . . . .        Number             0h 
_CALL_REPORTFAULT  . . . . . . .        Number             2h 
_CDecl . . . . . . . . . . . . .        Text   fastcall
_CONTROL . . . . . . . . . . . .        Number            20h 
_CRT_ALGO_DEFINED  . . . . . . .        Number             0h 
_CRT_ALLOCATION_DEFINED  . . . .        Number             0h 
_CRT_DOUBLE_DEC  . . . . . . . .        Number             0h 
_CRT_ERRNO_DEFINED . . . . . . .        Number             0h 
_CRT_PERROR_DEFINED  . . . . . .        Number             0h 
_CRT_SYSTEM_DEFINED  . . . . . .        Number             0h 
_CRT_TERMINATE_DEFINED . . . . .        Number             0h 
_CRT_WPERROR_DEFINED . . . . . .        Number             0h 
_CRT_WSYSTEM_DEFINED . . . . . .        Number             0h 
_CType . . . . . . . . . . . . .        Text   fastcall
_CVTBUFSIZE  . . . . . . . . . .        Number           15Dh 
_DIGIT . . . . . . . . . . . . .        Number             4h 
_DIV_T_DEFINED . . . . . . . . .        Number             0h 
_ERRNO_T_DEFINED . . . . . . . .        Number             0h 
_FILE_DEFINED  . . . . . . . . .        Number             0h 
_HEX . . . . . . . . . . . . . .        Number            80h 
_I16_MAX . . . . . . . . . . . .        Number          7FFFh 
_I16_MIN . . . . . . . . . . . .        Number     -00008000h 
_I32_MAX . . . . . . . . . . . .        Number      7FFFFFFFh 
_I32_MIN . . . . . . . . . . . .        Number     -80000000h 
_I64_MAX . . . . . . . . . . . .        Number      7FFFFFFFFFFFFFFFh 
_I64_MIN . . . . . . . . . . . .        Number      8000000000000000h 
_I8_MAX  . . . . . . . . . . . .        Number            7Fh 
_I8_MIN  . . . . . . . . . . . .        Number     -00000080h 
_IA64_ . . . . . . . . . . . . .        Number             0h 
_INC_SDKDDKVER . . . . . . . . .        Number             0h 
_INTIOBUF  . . . . . . . . . . .        Number          1000h 
_INTPTR_T_DEFINED  . . . . . . .        Number             0h 
_IOCOMMIT  . . . . . . . . . . .        Number          4000h 
_IOCTRLZ . . . . . . . . . . . .        Number          2000h 
_IOEOF . . . . . . . . . . . . .        Number            10h 
_IOERR . . . . . . . . . . . . .        Number            20h 
_IOFBF . . . . . . . . . . . . .        Number             0h 
_IOFEOF  . . . . . . . . . . . .        Number           800h 
_IOFLRTN . . . . . . . . . . . .        Number          1000h 
_IOLBF . . . . . . . . . . . . .        Number            40h 
_IOMYBUF . . . . . . . . . . . .        Number             8h 
_IONBF . . . . . . . . . . . . .        Number             4h 
_IOREAD  . . . . . . . . . . . .        Number             1h 
_IORW  . . . . . . . . . . . . .        Number            80h 
_IOSETVBUF . . . . . . . . . . .        Number           400h 
_IOSTRG  . . . . . . . . . . . .        Number            40h 
_IOWRT . . . . . . . . . . . . .        Number             2h 
_IOYOURBUF . . . . . . . . . . .        Number           100h 
_LABEL . . . . . . . . . . . . .        Number            40h 
_LOWER . . . . . . . . . . . . .        Number             2h 
_MAXIOBUF  . . . . . . . . . . .        Number          4000h 
_MAX_DIR . . . . . . . . . . . .        Number           100h 
_MAX_DRIVE . . . . . . . . . . .        Number             3h 
_MAX_ENV . . . . . . . . . . . .        Number          7FFFh 
_MAX_EXT . . . . . . . . . . . .        Number           100h 
_MAX_FNAME . . . . . . . . . . .        Number           100h 
_MAX_PATH  . . . . . . . . . . .        Number           104h 
_MINIOBUF  . . . . . . . . . . .        Number           200h 
_MSC_FULL_VER  . . . . . . . . .        Number       A21FE80h 
_MSC_VER . . . . . . . . . . . .        Number           6A4h 
_M_IA64  . . . . . . . . . . . .        Number             0h 
_M_X64 . . . . . . . . . . . . .        Number            64h 
_NSTREAM_  . . . . . . . . . . .        Number            14h 
_ONEXIT_T_DEFINED  . . . . . . .        Number             0h 
_OUT_TO_DEFAULT  . . . . . . . .        Number             0h 
_OUT_TO_MSGBOX . . . . . . . . .        Number             2h 
_OUT_TO_STDERR . . . . . . . . .        Number             1h 
_PUNCT . . . . . . . . . . . . .        Number            10h 
_REGS6432  . . . . . . . . . . .        Number             0h 
_REPORT_ERRMODE  . . . . . . . .        Number             3h 
_SPACE . . . . . . . . . . . . .        Number             8h 
_TCHAR_DEFINED . . . . . . . . .        Number             0h 
_THREADLOCALEINFO  . . . . . . .        Number             0h 
_UI16_MAX  . . . . . . . . . . .        Number          FFFFh 
_UI32_MAX  . . . . . . . . . . .        Number      FFFFFFFFh 
_UI64_MAX  . . . . . . . . . . .        Number     -00000001h 
_UI8_MAX . . . . . . . . . . . .        Number            FFh 
_UINTPTR_T_DEFINED . . . . . . .        Number             0h 
_UPPER . . . . . . . . . . . . .        Number             1h 
_WCHAR_T_DEFINED . . . . . . . .        Number             0h 
_WCTYPE_T_DEFINED  . . . . . . .        Number             0h 
_WIN32 . . . . . . . . . . . . .        Number             0h 
_WIN32_IE  . . . . . . . . . . .        Number           800h 
_WIN32_WINDOWS . . . . . . . . .        Number           410h 
_WIN32_WINNT . . . . . . . . . .        Number           601h 
_WINNT_WINNT . . . . . . . . . .        Number           601h 
_WRITE_ABORT_MSG . . . . . . . .        Number             1h 
_WSTDIO_DEFINED  . . . . . . . .        Number             0h 
_WSTDLIBP_DEFINED  . . . . . . .        Number             0h 
_WSTDLIB_DEFINED . . . . . . . .        Number             0h 
_WSTRING_DEFINED . . . . . . . .        Number             1h 
__ASMC_INC . . . . . . . . . . .        Number             0h 
__ERRMSG_INC . . . . . . . . . .        Number             0h 
__INC_VERSION  . . . . . . . . .        Number             0h 
__INTTYPE_INC  . . . . . . . . .        Number             0h 
__LIBC_INC . . . . . . . . . . .        Number             0h 
__LIBC__ . . . . . . . . . . . .        Number            E8h 
__LTYPE_INC  . . . . . . . . . .        Number             0h 
__NAMESPACE_INC  . . . . . . . .        Number             0h 
__QUEUE_INC  . . . . . . . . . .        Number             0h 
__STDC_WANT_SECURE_LIB__ . . . .        Number             1h 
__STDC__ . . . . . . . . . . . .        Number             0h 
__STDIO_INC  . . . . . . . . . .        Number             0h 
__STDLIB_INC . . . . . . . . . .        Number             0h 
__STRING_INC . . . . . . . . . .        Number             0h 
__SYMBOLS_INC  . . . . . . . . .        Number             0h 
__TOKEN_INC  . . . . . . . . . .        Number             0h 
__argc . . . . . . . . . . . . .        DWord              0h *External FASTCALL
__argv . . . . . . . . . . . . .        Near               0h *External FASTCALL
__ccall  . . . . . . . . . . . .        Text   fastcall
__cdecl  . . . . . . . . . . . .        Text   fastcall
__mb_cur_max . . . . . . . . . .        DWord              0h *External FASTCALL
__wargv  . . . . . . . . . . . .        Near               0h *External FASTCALL
_bufin . . . . . . . . . . . . .        Byte               0h *External FASTCALL
_countof . . . . . . . . . . . .        Text   lengthof
_doserrno  . . . . . . . . . . .        Text   errno_t ptr [__doserrno()]
_environ . . . . . . . . . . . .        Near               0h *External FASTCALL
_fmode . . . . . . . . . . . . .        DWord              0h *External FASTCALL
_iob . . . . . . . . . . . . . .        _iobuf             0h *External FASTCALL
_ltype . . . . . . . . . . . . .        Byte[129]          0h _DATA Public FASTCALL
_osfhnd  . . . . . . . . . . . .        Near               0h *External FASTCALL
_pgmptr  . . . . . . . . . . . .        Near               0h *External FASTCALL
_sys_errlist . . . . . . . . . .        Text   __sys_errlist()
_sys_nerr  . . . . . . . . . . .        Text   [__sys_nerr()]
_wenviron  . . . . . . . . . . .        Near               0h *External FASTCALL
_wpgmptr . . . . . . . . . . . .        Near               0h *External FASTCALL
errno  . . . . . . . . . . . . .        Text   errno_t ptr [_errno()]
errout . . . . . . . . . . . . .        Text   stdout
false  . . . . . . . . . . . . .        Number             0h 
hStdError  . . . . . . . . . . .        Near               0h *External FASTCALL
hStdInput  . . . . . . . . . . .        Near               0h *External FASTCALL
hStdOutput . . . . . . . . . . .        Near               0h *External FASTCALL
nullptr  . . . . . . . . . . . .        Number             0h 
regax  . . . . . . . . . . . . .        DWord              0h *External FASTCALL
stackreg . . . . . . . . . . . .        DWord              0h *External FASTCALL
stderr . . . . . . . . . . . . .        _iobuf             0h *External FASTCALL
stdin  . . . . . . . . . . . . .        Text   _iob
stdout . . . . . . . . . . . . .        _iobuf             0h *External FASTCALL
szDgroup . . . . . . . . . . . .        Byte               0h *External FASTCALL
true . . . . . . . . . . . . . .        Number             1h 
wcswcs . . . . . . . . . . . . .        Text   wcsstr
write_to_file  . . . . . . . . .        DWord              0h *External FASTCALL

