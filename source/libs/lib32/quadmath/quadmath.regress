include limits.inc
include errno.inc
include stdio.inc
include string.inc
include quadmath.inc

    .assert:on

    T equ <@CStr>

.template assert fastcall

    lastResult errno_t ?

    .static assert {

        mov this.lastResult,0
        _set_errno(0)
        }
;;;;;;;;

    .static __a :abs, :abs, :abs, :abs {
        local a, b, r
        .data
        align 16
        a oword _2
        b oword _3
        r oword _4
        .code
        __&_1&(addr a, addr b)
        mov eax,dword ptr a
        mov edx,dword ptr a[4]
        mov ebx,dword ptr r
        mov ecx,dword ptr r[4]
        .assert( eax == ebx && edx == ecx )
        mov eax,dword ptr a[8]
        mov edx,dword ptr a[12]
        mov ebx,dword ptr r[8]
        mov ecx,dword ptr r[12]
        .assert( eax == ebx && edx == ecx )
        }

    .static addo {
        this.__a(addo, 0, 0, 0)
        this.__a(addo, 1, 0, 1)
        this.__a(addo, 0x7FFFFFFF, 1, 0x80000000)
        this.__a(addo, 0x7FFFFFFFFFFFFFFF, 1, 0x8000000000000000)
        this.__a(addo, 0xFFFFFFFFFFFFFFFE, 1, 0xFFFFFFFFFFFFFFFF)
        this.__a(addo, 0xFFFFFFFFFFFFFFFF, 1, 0x10000000000000000)
        this.__a(addo, 0xFFFFFFFFFFFFFFFE, 2, 0x10000000000000000)
        }
    .static subo {
        this.__a(subo, 0, 0, 0)
        this.__a(subo, 1, 0, 1)
        this.__a(subo, 0x10000000000000000, 0xFFFFFFFFFFFFFFFF, 1)
        this.__a(subo, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, 1, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE)
        this.__a(subo, 0, 1, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
        }

    .static __m :abs, :abs, :abs, :abs=<0> {
        local a, b, r, o, h
        .data
        align 16
        a oword _2
        b oword _3
        r oword _4
        o oword _5
        h oword ?
        .code
        __mulo(addr a, addr b, addr h)
        mov eax,dword ptr a
        mov edx,dword ptr a[4]
        mov ebx,dword ptr r
        mov ecx,dword ptr r[4]
        .assert( eax == ebx && edx == ecx )
        mov eax,dword ptr a[8]
        mov edx,dword ptr a[12]
        mov ebx,dword ptr r[8]
        mov ecx,dword ptr r[12]
        .assert( eax == ebx && edx == ecx )
        mov eax,dword ptr h
        mov edx,dword ptr h[4]
        mov ebx,dword ptr o
        mov ecx,dword ptr o[4]
        .assert( eax == ebx && edx == ecx )
        mov eax,dword ptr h[8]
        mov edx,dword ptr h[12]
        mov ebx,dword ptr o[8]
        mov ecx,dword ptr o[12]
        .assert( eax == ebx && edx == ecx )
        }

    .static mulo {
        this.__m(0, 0, 0, 0)
        }

    .static __m dividend:abs, divisor:abs, :abs, :abs=<0> {
        local a, b, d, r, o
        .data
        align 16
        a oword dividend
        b oword divisor
        d oword _3
        r oword _4
        o oword ?
        .code
        __divo(addr a, addr b, addr o)
        mov eax,dword ptr a
        mov edx,dword ptr a[4]
        mov ebx,dword ptr d
        mov ecx,dword ptr d[4]
        .assert( eax == ebx && edx == ecx )
        mov eax,dword ptr a[8]
        mov edx,dword ptr a[12]
        mov ebx,dword ptr d[8]
        mov ecx,dword ptr d[12]
        .assert( eax == ebx && edx == ecx )
        mov eax,dword ptr o
        mov edx,dword ptr o[4]
        mov ebx,dword ptr r
        mov ecx,dword ptr r[4]
        .assert( eax == ebx && edx == ecx )
        mov eax,dword ptr o[8]
        mov edx,dword ptr o[12]
        mov ebx,dword ptr r[8]
        mov ecx,dword ptr r[12]
        .assert( eax == ebx && edx == ecx )
        }

    .static divo {
        this.__m(0, 0, 0)
        }


;;;;;;;;

    .static SetStatus :abs {

        .new status:errno_t
        ifnb <_1>
            mov status,_1
        else
            _get_errno(&status)
            _set_errno(0)
        endif
        mov eax,status
        .if eax
            mov this.lastResult,eax
        .endif
        }
    .ends

    .code

main proc

    .new this:assert()

    ; */+-

    this.mulo()
    this.divo()
    this.addo()
    this.subo()

    this.SetStatus()
    ret

main endp

    end
